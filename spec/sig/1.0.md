<!-- draft -->
# `vt6/sig1.0` - Signal delivery from server to client

This document specifies version `1.0` of the VT6 module `sig`.
Refer to this document using the identifier `vt6/sig1.0` or its canonical URL <https://vt6.io/std/sig/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## 1. Introduction

This module defines a set of messages that servers can send to clients, which are called **signals**.
A VT6 server typically sends such a signal when the user presses the corresponding key sequence.
A VT6 proxy typically sends such a signal to its clients when receiving a similar signal from its own server.

### 1.1. The signal dispatcher

Signals are sent to at most one client, which is called the server's **signal dispatcher**.
The signal dispatcher is that client which has most recently sent a valid `sig.claim` message to the server, out of the set of clients which have ever sent such a message and which have not yet closed the server connection over which the message has been sent.
If no such client exists, there is no signal dispatcher.

When multiple clients are running, it is the signal dispatcher's responsibility to decide whether and how to dispatch a signal to other clients, possibly in platform-specific ways.

*Rationale:* In the usual scenario, where the terminal emulator (the server) starts up a shell, which then takes care of launching other programs, the shell is the signal dispatcher.
This is why the shell must be the signal dispatcher: Signals typically only go to programs running in the foreground, and only the shell can decide reliably which programs run in the foreground.

When there is no signal dispatcher, the server SHOULD dispatch signals to clients in a platform-specific way.

*Rationale:* It is tempting to just send the signal to every client, but the server cannot know whether an arbitrary client is prepared to handle VT6 signals.
When a client sends the messages `(want sig1)(sig.claim)`, that constitutes sufficient proof that this client can handle signals.

### 1.2. Foreground processes

If the signal dispatcher is a client process which allows the user to create further client processes (e.g., a shell), then client processes created by it are said to **run in the foreground** if the user cannot interact with the signal dispatcher to create further client processes while the client process in the foreground is still running.

*Rationale:* If the signal dispatcher is a shell, this means that programs started by it are running in the foreground if you don't get the next prompt until the program in the foreground has been suspended or terminated.

TODO add reference to the module defining frames, which extends this semantic

## 2. Message types for `vt6/sig1.0`

Every message type defined below is a signal, except for `sig.claim`.

For most signals, a key sequence is stated which usually causes terminals to emit that signal.
Terminal implementations MAY choose to respond to different key sequences instead, or to offer input methods other than a key sequences, or no input methods at all.

### 2.1. The `sig.claim` message

- Directionality: client to server
- Required capabilities: none
- Number of arguments: none

When a client sends a `sig.claim` message to its server, it becomes the signal dispatcher for this server.
It will receive all signal messages defined below while it is the signal dispatcher, and no one else will.

### 2.2. The `sig.interrupt` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal dispatcher to indicate that the user wishes to interrupt the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients MAY choose to ignore or postpone it.

*Rationale:* This signal is analogous to the POSIX signal SIGINT, and usually generated by the key sequence `Ctrl-C`.

### 2.3. The `sig.quit` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal dispatcher to indicate that the user wishes to terminate the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients SHOULD NOT ignore it.

*Rationale:* This signal is analogous to the POSIX signal SIGQUIT, and usually generated by the key sequence `Ctrl-\`.

### 2.4. The `sig.suspend` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal dispatcher to indicate that the user wishes to suspend the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients can not ignore it or react to it in any way other than immediate suspension.
The signal dispatcher (or, if there is no signal dispatcher, the server) SHALL provide a method for the user to resume clients suspended in this way.

*Rationale:* This signal is analogous to the POSIX signal SIGSTOP, and usually generated by the key sequence `Ctrl-Z`.
Suspension is useful when the user wants to enter another shell command without interrupting or terminating the clients running in the foreground.
