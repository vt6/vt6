<!-- draft -->
# `vt6/sig1.0` - Signal delivery from server to client

This document specifies version `1.0` of the VT6 module `sig`.
Refer to this document using the identifier `vt6/sig1.0` or its canonical URL <https://vt6.io/std/sig/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## 1. Introduction

This module defines a set of messages that servers can send to clients, which are called **signals**.
A server typically sends such a signal when the user presses the corresponding key sequence.
A proxy typically sends such a signal to its clients when receiving a similar signal from its own server.

### 1.1. The signal receiver

Signals are sent to at most one client, which is called the server's **signal receiver**.
The signal receiver is that client which has most recently sent a `sig1.receive` message to the server, and which has not yet closed the server connection over which the message has been sent.
If no such client exists, there is no signal receiver.

When multiple clients are running, it is the signal receiver's responsibility to decide whether and how to dispatch a signal to other clients, possibly in platform-specific ways.

*Rationale:* In the usual scenario, where the terminal emulator (the server) starts up a shell, which then takes care of launching other programs, the shell is the signal receiver.
This is why the shell must be the signal receiver: Signals typically only go to programs running in the foreground, and only the shell can decide reliably which programs run in the foreground.

When there is no signal receiver, the server SHOULD dispatch signals to clients in a platform-specific way.

*Rationale:* It is tempting to just send the signal to every client, but the server cannot know whether an arbitrary client is prepared to handle signals.
When a client sends the messages `(have sig1)(sig1.receive)`, that constitutes sufficient proof that this client can handle signals.

### 1.2. Foreground processes

If the signal receiver is a client process which allows the user to create further client processes (e.g., a shell), then client processes created by it are said to **run in the foreground** if the user cannot interact with the signal receiver to create further client processes while the client process in the foreground is running.

*Rationale:* If the signal receiver is a shell, this means that programs started by it are running in the foreground if you don't get the next prompt until the program in the foreground has been suspended or terminated.

TODO add reference to the module defining frames, which extends this semantic

## 2. Message types for `vt6/sig1`

Every message type defined below is a signal, except for `sig1.receive`.

For most signals, a key sequence is stated which usually causes terminals to emit this signal.
However, these statements are only informational.
Terminal implementations MAY choose to respond to different key sequences instead, or to offer input methods other than a key sequences, or no input methods at all.

### 2.1. The `sig1.receive` message

- Directionality: client to server
- Required capabilities: none
- Number of arguments: none

When a client sends a `sig1.receive` message to its server, it becomes the signal receiver for this server.
It will receive all signal messages defined below while it is the signal receiver, and no one else will.

### 2.2. The `sig1.interrupt` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal receiver to indicate that the user wishes to interrupt the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients MAY choose to ignore or postpone it.

*Rationale:* This signal is analogous to the POSIX signal SIGINT, and usually generated by the key sequence `Ctrl-C`.

### 2.3. The `sig1.quit` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal receiver to indicate that the user wishes to terminate the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients SHOULD NOT ignore it.

*Rationale:* This signal is analogous to the POSIX signal SIGQUIT, and usually generated by the key sequence `Ctrl-\`.

### 2.4. The `sig1.suspend` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: none

The server sends this message to the signal receiver to indicate that the user wishes to suspend the clients which are currently running in the foreground.
The interrupt SHALL be delivered in such a way that clients can not ignore it or react to it in any way other than immediate suspension.
The signal receiver SHALL provide a method for the user to resume clients suspended in this way.

*Rationale:* This signal is analogous to the POSIX signal SIGSTOP, and usually generated by the key sequence `Ctrl-Z`.
Suspension is useful when the user wants to enter another shell command without interrupting or terminating the clients running in the foreground.
