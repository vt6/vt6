<!-- draft -->
# `vt6/core1.0` - Fundamental protocols and interface contracts

This document specifies version `1.0` of the VT6 module `core`.
Refer to this document using the identifier `vt6/core1.0` or its canonical URL <https://vt6.io/std/core/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## 1. Definitions and platform requirements

The VT6 protocol is divided into **modules**.
A process which implements VT6 modules and exposes them to other processes is called a **VT6 server**.
A process that consumes this functionality is called a **VT6 client**.
A process that acts both as a VT6 client to at least one process and as a VT6 server to at least one process at the same time is called as **VT6 proxy**.

*Rationale:* In the most common setup (programs being started by a shell inside a terminal emulator), the terminal emulator acts as the server.
The shell and the programs started by it are the clients.

A **platform** is an operating environment which is admissible for VT6 clients and/or servers.

A platform for VT6 servers SHALL define how a server can launch other processes which can then act as VT6 clients, or it alternatively SHALL define a method for the server to delegate this task to other processes.

A **bidirectional text stream** is an object from which byte strings can be read and into which byte strings can be written.
A VT6 client SHALL have access to a bidirectional text stream, which is called this client's **standard input/output**.

A platform MAY define a method by which clients can gain access to further bidirectional text streams.
Text streams obtained through this method are called **server connections**.
When a client writes a byte string into a server connection, it MUST NOT be received by any process but this client's server.
When a client reads a byte string from a server connection, it SHALL have been sent by this client's server.
The server SHALL be able to distinguish between server connections opened by different clients, as well as different server connections opened by the same client.
This does not necessarily mean that the server can identify which server connection belongs to which client process.

*Rationale:* The server connection is separate from the standard input and output for scenarios where the VT6 client must be certain that the messages it sends are received by the VT6 server and not by another party (such as the next client in a shell pipe), and vice versa for server-to-client messages.
In POSIX, the server connection replaces the [special capabilities of terminal devices](https://linux.die.net/man/3/termios).

If the platform allows VT6 client processes to be started while a VT6 server is not present, the platform MUST define a method for client processes to determine whether a VT6 server is present.
If no VT6 server is present, the client process SHALL not be considered a VT6 client for the purpose of this specification, and any other specifications that inherit the meaning of the term "VT6 client" from it.

If a VT6 client has a method to obtain server connections, it is said to be operating in **normal mode**.
Otherwise, it is said to be operating in **multiplexed mode**.

*Rationale:* The multiplexed mode is intended for clients which only have a single bidirectional text stream to their server and have no way of establishing a separate bidirectional text stream to use as a server connection.
The most prominent example of this is a client connected via a remote login protocol such as [SSH](https://tools.ietf.org/html/rfc4251).

### 1.1. Platforms

A platform is defined by a **platform integration module**, which is a VT6 module (see section 3).

For each official module (see section 3.3) that references **platform-specific behavior**, the specification for each platform integration module MUST define said behavior for its platform, or it MUST define that the module referencing platform-specific behavior is not supported on its platform.

A platform integration module MAY define message types and properties (see section 3) which are only available on the platform defined by it.

*The remainder of this section is non-normative.*

The following platform integration modules are available at the time of publication of this document:

- [vt6/posix](../posix/) for operating systems that implement the POSIX specification

## 2. Messages

This section uses augmented Backus-Naur form (ABNF) as defined in [RFC5234](https://tools.ietf.org/html/rfc5234).

### 2.1. S-expression format

```abnf
s-expression    = "(" *space *( ( s-expression / atom ) *space ) ")"

atom            = bareword / quoted-string

bareword        = 1*( letter / digit / "." / "-" / "_" )

quoted-string   = quote *( quoted-char / bslash ( bslash / quote ) ) quote

quote   = %x22              ; " (double quote)
bslash  = %x5C              ; \ (backslash)
digit   = %x30-39           ; decimal digits 0-9
nzdigit = %x31-39           ; non-zero decimal digits 1-9
letter  = %x41-5A / %x61-7A ; letters A-Z and a-z
space   = %x20 / %x09-0D    ; ASCII characters which are accepted by isspace() under the C locale
```

Furthermore, the `<quoted-char>` element accepts all byte strings which encode exactly one Unicode character using the UTF-8 encoding, except for the ASCII backslash or the ASCII double quote.

*Rationale:* [utf8everywhere.org](http://utf8everywhere.org) nicely sums up the arguments for not bothering with other text encodings.

An **s-expression** is a parenthesis-delimited sequence of atoms or other s-expressions, which are referred to as the s-expression's **elements**.
Whitespace (sequences of `<space>`) between the parentheses and atoms is ignored.
For example, the following three s-expressions are equivalent.

```vt6
(foo bar)

(           foo bar)

(foo   bar   )
```

The **length** of an s-expression is the number of elements that it contains.
Any element that is an s-expression itself counts as one element regardless of how many elements it contains.
For example, the length of the s-expression `(a (b c) d)` is 3.
The shortest s-expression is the empty s-expression, `()`, with length 0.

An **atom** is either a bareword or a quoted string.
Each atom **represents** a string of Unicode characters.

A **bareword** is a sequence of ASCII letters, digits, dots, dashes or underscores, such that the first character is a letter.
A bareword **represents** itself.

```
bareword             valid
example-bareword     valid
example3.0           valid
example bareword     invalid (contains whitespace)
5example             invalid (does not start with letter)
"bareword"           invalid (contains forbidden ASCII character)
¯\_(ツ)_/¯           invalid (contains character not in ASCII)
```

A **quoted string** is a string of printable Unicode characters in the UTF-8 encoding, except for the double quote or backslash, enclosed by double quotes.
The quoted string **represents** the string of characters between its enclosing quotes, except for escaping rules as noted below.
For example, the quoted string `"abc"` represents the same 3-letter string as the bareword `abc`.

A quoted string may represent a string containing double quotes or backslashes, if these characters are escaped by inserting a backslash before them.
For example, the quoted string `"ab\\\"cd\""` represents the string `ab\"cd"`.
For each string of Unicode characters, there exists exactly one quoted string that represents it.

*Rationale:* We avoid compactly-coded escape sequences like those specified by [ECMA-48](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-48,%202nd%20Edition,%20August%201979.pdf) aka ANSI&nbsp;X3.64 aka ISO/IEC&nbsp;6429 because of the risk that escape sequences specified by different modules collide with each other.
We choose s-expressions because they can be implemented very easily, both on the generating and on the parsing side.
They are as flexible and human-readable as JSON, TOML or YAML, but at the same time more compact than either of those.
We do not include support for additional escape sequences in quoted strings because there is no apparent need for them.
Users generating s-expressions will be using a programming or scripting language, and can take advantage of the escape sequences provided by these languages' string literals.
Each s-expression adhering to this specification is also a valid UTF-8-encoded string, so implementations can reuse existing Unicode support libraries.

### 2.2. Message format

```abnf
strict-bareword = ( letter / "_" ) *( letter / "-" / "_" )

module-name  = strict-bareword
scoped-name  = module-name "." strict-bareword
message-type = "want" / "have" / "nope" / scoped-name

message        = "(" *space message-type *space *( ( s-expression / atom ) *space ) ")"
```

A **VT6 message** (or just **message**, if the term is not ambiguous) is a nonempty s-expression whose first element is an atom that is accepted by `<message-type>`.
The first element of a message is therefore called the message's **type**.
Any following elements of a message are called the message's **arguments**.
A message may have arbitrarily many arguments, including zero arguments.
As can be seen in the grammar definition above, a message type name consists of a module name (see section 3.1) and a strict bareword, separated by a dot (see section 3.3).
As an exception, the message types "want", "have" and "nope" do not contain a module name (see sections 4 and 5).

```abnf
message-stream = *( *space message ) *space
```

A **VT6 message stream** (or just **message stream**, if the term is not ambiguous) is a sequence of VT6 messages which are optionally preceded, succeeded and/or separated by whitespace.

*Rationale:* Allowing for whitespace between messages is especially useful when messages are emitted by a script in a language where a `print` operation appends a line separator by default.
As with s-expressions above, a message stream is also a valid UTF-8-encoded string, so implementations can reuse existing Unicode support libraries.

```abnf
fenced-message-stream = escape-char message-stream escape-char

escape-char = %x1B
```

A message stream is **fenced** when it is preceded by one ESC character and succeeded by another ESC character.

### 2.3. Server-client communication

When a VT6 client is running in normal mode, it sends messages to its server by writing a message stream into a server connection, and receives messages from the server by reading a message stream from the same server connection.
Furthermore, it can read input data from standard input and write output data to standard output.
This specification does not restrict the form of these input and output data.

When a VT6 client is running in multiplexed mode, it sends messages to its server by writing a *fenced* message stream onto the standard output.
Any ESC character that is part of the output data or of a message inside the fenced message stream must be escaped by doubling it.

Conversely, a VT6 client running in multiplexed mode receives messages from its server by reading a *fenced* message stream from the standard input, whenever a single ESC character is encountered.
Any two consecutive ESC characters SHALL be interpreted as a single ESC character in the input data or in the current message.

A VT6 client running in multiplexed mode MUST write the magic string `<ESC>[6V` (decimal byte sequence 27, 91, 54, 126) into the standard output before writing anything else.
The magic string is not considered to be part of the output data nor does it start a fenced message stream, so the escaping rule for ESC characters stated above does not apply.

If the client fails to do so, all data written by the client into its standard output MUST be considered output data and the escaping rule for ESC characters does not apply.
Furthermore, fenced message streams MUST NOT be written into the client's standard input, and the escaping rule for ESC characters does not apply to the input data written into it, either.

### 2.4. Invalid messages, and handling thereof

A message is **invalid** if...

- the message is not accepted by `<s-expression>`,

- the message's first element is not an atom accepted by `<message-type>`,

- the message's arguments do not conform to the requirements for the message's type, as stated in the specification defining the message type in question,

- the size of the bytestring encoding the message exceeds the recipient's maximum message size (see sections 6.1 and 6.2), usually 1024 bytes, or

- the message type is unknown or its use has not been agreed to by the server (see section 4).

A VT6 server receiving an invalid message from a VT6 client MUST act towards the client as if the message had never been received at all, and vice versa for messages from the server to the client.

A VT6 client or server MAY continue parsing and acting on a partially received message only if it is able to rollback all actions performed because of this message if the message turns out to be invalid once fully received, or if the connection is lost before the message is fully received.
This only concerns actions that are performed towards the sender of the message.
For example, the action of a server reporting a malformed client message to the user is not restricted by this rule, since the action is towards the user rather than the VT6 client.

If, while parsing a message stream, a message in the stream exceeds the recipient's maximum message size, the recipient SHOULD employ the following algorithm to reset the stream parser and find the next well-formed message.

1. Discard all input characters until a `(` character is found, without keeping track of whether the `(` is inside a quoted string or not.
2. Try to parse a message starting from this character.
3. If no valid message could be read, go back to step 1.

*Rationale:* In step 1, we explicitly recommend to ignore quotes because, given the simple syntax of s-expressions, the most likely syntax error (other than unbalanced parentheses) is malformed quoted strings because of unescaped quotes or backslashes.

## 3. Modules

The VT6 protocol specification is divided into **modules**, each of which MUST have a **name** which is accepted by `<module-name>` (see section 2.2).
For example, this document specifies the `core` module.

Each module contains the message types and properties defined in its specification (see below).
Each message type MUST have a **name** which is accepted by `<message-type>` (see section 2.2).
Each property MUST have a **name** which is accepted by `<scoped-name>` (see section 2.2).

For each message type and property (except for the `want`, `have` and `nope` message types defined in sections 4 and 5), the part of its name before the dot MUST be equivalent to the name of the module whose specification defines it.
For example, a module with a name of `example2` may define a message type named `example.foo` and a property named `example.bar`, but not a message type named `sample.foo` or a property named `sample.bar`.

Each **message type** is defined by its name and a set of criteria describing when a message whose first element is the message type's name is to be considered valid by the recipient.
These criteria include at least:

- the directionality (whether the message may be sent from a client to a server, or vice-versa, or both),
- the number of arguments that a message of this type may contain,
- the format and/or structure of said arguments,
- the behavior that is expected of the recipient party upon having received the message.

A **property** is a quantifiable aspect which describes the server or the server connection over which messages concerning this property are exchanged.
Each concrete value of a property is represented as either an `<atom>` or an `<s-expression>`.
The value of a property may influence how the server reacts to a message from the client.
It may also influence how the client reacts to a message from the server if (and only if) the client has subscribed to this property (see section 6.1).

Each property is defined by its name and at least the following criteria:

- the set of values that the property can have,
- whether, and under which circumstances, the client may set the property's value (see section 6.3),
- how the behavior of client and server is influenced by the value of this property.

For each message type in a module, that module SHALL NOT contain a property of the same name.

*Rationale:* Even though technically possible, it would cause unnecessary confusion.

### 3.1. Module versions

```abnf
version-number = "0" / ( nzdigit *digit )

major-version = version-number
minor-version = version-number
full-version  = major-version "." minor-version
```

Each specification of a module has a **major version number** and a **minor version number**, as accepted by the `<major-version>` and `<minor-version>` grammar elements defined above.
When both version numbers are shown together, they are formatted as implied by the definition of the `<full-version>` grammar element defined above.

When the first specification of a module is created, its major and minor version number MUST be set to 1 and 0, respectively.
A module specification MUST clearly indicate its major and minor version number.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document specifies version `<full-version>` of the VT6 module `<module-name>`.
> Refer to this document using the identifier `vt6/<module-name><full-version>` or its canonical URL `<stable-url-to-module-spec>`.

Everytime a new release of the module specification is made, its version number MUST be adjusted as follows:

1. The minor version number is incremented.
2. If the module specification has been changed in a backwards-incompatible way compared to the previous release, the major version number is incremented and the minor version number is reset to 0.

This requirement does not apply when the release is only a draft or pre-release that is not considered normative, and clearly labeled as such.

**Rationale:** This follows the basic notion of [semantic versioning](http://semver.org/spec/v2.0.0.html), albeit massively simplified to suit the usecase of module specifications.

Each module specification whose minor version number is bigger than 0 SHOULD indicate which parts of it have been added or changed compared to previous specifications of that module with the same major version number.

**Rationale:** Implementors should not have to `diff` specification documents manually.

### 3.2. Compatibility across versions

The following changes to a module specification are considered **backwards-compatible**:

- definition of a new message type or property
- deprecation (but not removal) of an existing message type or property
- definition of previously undefined or underdefined behavior of an existing message type or property
- copyediting

Every other change to a module specification is considered **backwards-incompatible**, especially:

- removal of a message type or property
- change of behavior of an existing message type or property in such a way that there may exist programs that conform to the previous minor version of the specification, but not to the current one

As an additional rule, all versions of the `core` module MUST be backwards-compatible with the parts of this specification that relate to all client and server behavior that takes place before a concrete version of the `core` module has been agreed to by the server.
This includes, specifically:

- the parts of sections 1 and 2.3 that describe how client and server establish a connection to each other and use it to exchange messages, and
- the syntax of `want`, `have` and `nope` messages as described in sections 2.1 and 4.
  Those message types are therefore called **eternal**.

The backwards-compatibility requirement across major versions of `core` does not apply to those parts of the message syntax that can only be used after the initial `want` and `have` messages (namely, quoted strings and nested s-expressions).

### 3.3. Module naming conventions

A module is considered **official** if its specifications are developed in the same location as this specification.
The name of any unofficial module MUST start with a leading underscore and SHOULD indicate the organization that is responsible for its specification.

A module is considered **private** if it is intended to be used by client and server implementations of a single vendor.
The name of any private module SHOULD start with two leading underscores.

*Rationale:* We strive to avoid name clashes between modules by different vendors, and reserve short module names for official modules to minimize message length for common messages.

### 3.4. Predefined property types

```abnf
integer          = "0" / ( [sign] nzdigit *digit )
unsigned-integer = "0" / ( nzdigit *digit )

sign = "+" / "-"
```

When a property is said to **accept integer values**, this means that the set of acceptable values for this property is the set of all atoms whose string value matches the `<integer>` grammar element defined above.
Analogously, when a property is said to **accept unsigned integer values**, this means that the set of acceptable values for this property is the set of all atoms whose string value matches the `<unsigned-integer>` grammar element defined above.

In both these cases, the numerical value of each such atom is that value which is returned when the `atoll()` function as defined in [the POSIX.1 specification](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoll.html) is applied to the string value of the atom.
The module specification defining the property may impose additional restrictions on the numerical value of the property.

Section 7 of this specification uses the property types defined in this section.
Other module specifications which use some or all of the property types defined in this section SHALL reference this section.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document uses the predefined property types from section 3.4 of the `vt6/core1.0` specification.

## 4. Protocol negotiation

Before a client can use the message types and properties of a module, usage of the module must have been agreed to by the server.
A server **agrees to** using a module by answering a `want` message from the client with a `have` message.

### 4.1. The `want` message

- Directionality: client to server
- Number of arguments: two or more

Each argument MUST be a bareword.
Quoted strings are not allowed in this message.

*Rationale:* The syntax of the `want` message is deliberately minimized because of the compatibility requirements in section 3.2.

A client can send a `want` message to the server to request usage of a module.
The first argument MUST be the module name, and the remaining arguments SHALL be the major versions of that module that the client supports.
For example, the following `want` message indicates that the client wants to use either major version 1 or major version 2 of the `example` module.

```vt6
(want example 1 2)
```

The first message that a client sends on each server connection MUST be a `want` message requesting the `core` module.

*Rationale:* All other modules depend on the definitions in `core`, so it must be negotiated first.

### 4.2. The `have` message

- Directionality: server to client
- Number of arguments: zero or two

Each argument MUST be a bareword.
Quoted strings are not allowed in this message.

*Rationale:* Same as in section 4.1.

Upon receiving a valid `want` message, the server MUST reply with a `have` message to indicate if it agrees to using the requested module.
If the `want` message is valid, but the server does not agree to the requested module, it MUST reply with a `have` message with zero arguments.

If the server agrees to using the requested module, it MUST reply with a `have` message with two arguments: the module name and the full version of the specification supported by the server.
Receipt of this `have` message entitles the client to use all message types, properties and behavior defined in a specification of that module with the same major version number and the same, or a smaller, minor version number.
The full version MUST be formatted according to the `<full-version>` grammar element defined above.
The major version contained therein MUST be one of the major versions that appeared in the original `want` message.

The server MUST NOT agree to using a module if it does not support any of the major versions of that module which were offered in the `want` message.
The server MUST NOT agree to using multiple major versions of the same module, neither in a single `have` message or across multiple `have` messages on the same server connection.
The server MAY agree to using different major versions of the same module on different server connections.

When a `want` message concerns the same module as an earlier `want` message, the server MUST reply consistently.
If it agreed to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST agree to this major version and offer the same full version as in the earlier `have` message.
If it did not agree to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST NOT agree to this major version.

The following snippet shows examples of valid and invalid streams of `want` messages and `have` replies.
Each set of messages, as separated by an empty line, is to be considered as occurring on separate server connections.

```vt6
(want core 1)
(have core 1.0)
(want foo 2)
(have foo 2.3)
--> client can now use core1.0 module and either foo2.0, foo2.1, foo2.2 or foo2.3 module

(want core 1 2)
(have core 2.1)
--> client can now use either core2.0 or core2.1 module, but not core1.x modules

(want core 1)
(have core 1.0)
(want foo 1 2)
(have)
--> server did not agree to using foo module
```

The server is under no obligation of agreeing to any module.
Clients should be prepared to gracefully handle unavailable modules.
If the client finds that the server has not agreed to a module that the client needs, it must exit.

## 5. Other eternal message types

### 5.1. The `nope` message

- Directionality: any
- Number of arguments: none

Upon receiving an invalid message, a server or client MAY reply by sending a `nope` message with no arguments.
It MUST do so if:

1. it cannot determine the message type of the invalid message, or
2. it can determine, based on the message type of the invalid message, that the sender is waiting for a reply.

As an exception, the recipient SHALL NOT send a `nope` message when a module that the server has agreed to mandates a different behavior for the invalid message in question.

*Rationale:* The purpose of the `nope` message is solely to unblock any processes which are waiting for a reply to their previous message.
This module does not define any generic error reporting mechanisms beyond this message type.
We consider it pointless to try to get any misbehaving process to start behaving correctly by pointing out their errors to them.

## 6. Message types for `vt6/core1.0`

### 6.1. The `core.sub` message

- Directionality: client to server
- Number of arguments: one or more

A client can send a `core.sub` message to establish a **subscription** to a nonzero number of properties.
The arguments of the `core.sub` message are the names of the properties which the client wishes to subscribe to.

*Rationale:* It is intentional that subscribing to a property is the only way for a client to retrieve a property's value.
This design nudges implementors towards handling server-initiated changes to properties properly.
Clients which only want to get the value of a property once are free to ignore any subsequent `core.pub` messages.

A `core.sub` message is invalid (within the meaning of section 2.4) if any of its arguments is:

- not the name of a property, or
- the name of a property in a module to whose usage the server has not agreed.

When a server receives a valid `core.sub` message, it MUST subscribe the sending client to all properties in the message's argument list, and immediately notify the client with a corresponding `core.pub` message (see below).

### 6.2. The `core.pub` message

- Directionality: server to client
- Number of arguments: two or more (must be even)

A server can send a `core.pub` message to inform a client of the values of certain properties.
It MUST have an even number of arguments.
The argument list consists of pairs of property names and property values.
That is, the second argument is the value of the property whose name is the first argument; the fourth argument (if present) is the value of the property whose name is the third argument; and so on.

A `core.pub` message is invalid (within the meaning of section 2.4) if any of its odd-numbered arguments is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed, or
- the name of a property to which the recipient of the `core.pub` message has not subscribed.

Moreover, a `core.pub` message is invalid if any of its even-numbered arguments is a property value which is not valid for the property in question according to the specification defining the property.

A `core.pub` message can be sent by the server at any time to notify the client of changes to the values of properties that the client has subscribed to.
Moreover, a `core.pub` message MUST be sent by the server immediately upon receiving a valid `core.sub` or `core.set` message.
This message MUST contain the values of all properties named in the `core.sub` or `core.set` message, in the same order.
For `core.sub` messages, this applies regardless of whether the client sending the message subscribes to properties for the first time, or whether subscriptions to these properties already existed for this client.

The following snippet shows examples of valid and invalid pairs of `core.sub` messages and `core.pub` replies.
The snippet is not a single message stream.
Each pair of messages is to be considered individually.
The snippet assumes that `foo.bar` and `foo.baz` are properties which are defined by the module `foo1` and which can assume arbitrary values, and that the server has agreed to using `foo1`.

```vt6
(core.sub foo.bar foo.baz)
(core.pub foo.bar hello-world foo.baz 20)
--> valid; property "foo.bar" has the value "hello-world" and "foo.baz" has the value "20"

(core.sub foo.bar foo.baz)
(core.pub foo.bar "hello-world" foo.baz "20")
--> valid, and semantically identical to the previous example since the bareword hello-world represents the same string as the quoted string "hello-world"

(core.sub foo.bar foo.baz)
(core.pub foo.bar (hello (world)) foo.baz 20)
--> valid; property values may be arbitrarily complex s-expressions if the spec defining the property allows it

(core.sub foo.bar foo.baz)
(core.pub foo.bar hello-world foo.baz)
--> invalid; odd number of arguments

(core.sub foo.bar foo.baz)
(core.pub foo.bar hello-world)
--> invalid; missing a property mentioned in the `core.sub` message

(core.sub foo.bar foo.baz)
(core.pub foo.bar hello-world foo.baz 20 foo.extra 10)
--> invalid; references a property not mentioned in the `core.sub` message

(core.sub foo.bar foo.baz)
(core.pub foo.baz 20 foo.bar hello-world)
--> invalid; properties not listed in correct order
```

### 6.3. The `core.set` message

- Directionality: client to server
- Number of arguments: two or more (must be even)

A client can send a `core.set` message to change the value of one or more properties.
The argument list of a `core.set` message has the same form as that of a `core.pub` message (pairs of property names and values).

A `core.set` message is invalid (within the meaning of section 2.4) if any of its odd-numbered arguments is:

- not the name of a property, or
- the name of a property in a module to whose usage the server has not agreed.

Notably, the message is not invalid if any of its even-numbered arguments is a value that is not permissible for the property in question.

*Rationale:* For non-trivial properties, the client might not have enough information to decide whether a given value is valid.

Setting a property implies subscribing to the property.
That is, a `core.set` message sent from a client to a server implies a `core.sub` message from the same client to the same server that mentions the same properties that are mentioned in the `core.set` message.
This does not mean, however, that a separate `core.pub` message must be sent to answer the implied `core.sub` message.
For example:

```vt6
# this message...
(core.set foo.bar value1 foo.baz value2)
# ...implies this message...
(core.sub foo.bar foo.baz)
# ...and may result in a reply like this
(core.pub foo.bar value1 foo.baz value3)
```

*Rationale:* For properties that only need to be set once, this reduces the number of messages required from four (sub-pub-set-pub) to two (set-pub).

A client's request to change the value of a property does not imply any obligation of the server to comply with this request.
The server may refuse to change the property's value at all (especially if the property is read-only), it may comply with the request, or set the property to an entirely different value, as long as the value is valid according to the property's specification.
This is why a `core.pub` message is sent as a reply for a `core.set` message.
The client SHOULD observe the `core.pub` reply to learn whether the requested changes were accepted.

*Rationale:* For example, consider the case of the client trying to set `core.client-msg-bytes-max` to `32768`.
The server might reject this, and report the previous value in the `core.pub` response; or it might choose a value inbetween the previous and the requested value because it absolutely cannot process messages larger than that.

## 7. Properties for `vt6/core1.0`

### 7.1. The `core.server-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the server to the client in bytes.
The default value of this property MUST NOT be larger than 1024.

*Rationale:* The upper limit is important because clients are therefore assured that a 1 KiB buffer can hold any single message sent by the server, unless a different limit is negotiated.
We choose this standard buffer size of 1 KiB such that most, if not all, messages that ever need to be sent fit into this buffer, without wasting too much memory on buffers.

### 7.2. The `core.client-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the client to the server in bytes.
The default value of this property MUST NOT be smaller than 1024.

*Rationale:* The lower limit is important because clients are therefore assured that any messages smaller than 1 KiB will be accepted by any server, unless a different limit is negotiated.
The rationale from section 7.1 applies respectively.

The client MUST observe the server response when setting this property, because the server may reject the new property value or choose a compromise value.
