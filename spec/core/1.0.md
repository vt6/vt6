<!-- draft -->
# `vt6/core1.0` - Fundamental protocols and interface contracts

The canonical URL for this document is <https://vt6.io/std/core/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

This document uses augmented Backus-Naur form (ABNF) as defined in [RFC5234](https://tools.ietf.org/html/rfc5234).

## 1. Definitions and platform requirements

### 1.1. Servers and clients

VT6 is a protocol which is spoken between **VT6 servers** and **VT6 clients**.
A process that acts both as a VT6 client to at least one process and as a VT6 server to at least one process at the same time is called as **VT6 proxy**.

*Rationale:* In the most common setup (programs being started by a shell inside a terminal emulator), the terminal emulator acts as the server.
The shell and the programs started by it are the clients.

A **platform** is an operating environment which is admissible for VT6 clients and/or servers.

A platform for VT6 servers SHALL define how a server can launch other processes which can then act as VT6 clients, or it alternatively SHALL define a method for the server to delegate this task to other processes.

If the platform allows VT6 client processes to be started while a VT6 server is not present, the platform MUST define a method for client processes to determine whether a VT6 server is present.
If no VT6 server is present, the client process SHALL not be considered a VT6 client for the purpose of this specification, and any other specifications that inherit the meaning of the term "VT6 client" from it.

### 1.2. Server connections

A **bidirectional byte stream** is an object from which byte strings can be read and into which byte strings can be written.
A bidirectional byte stream is either in **stdio mode**, in **message mode** or in **multiplexed mode**.
The semantics of message mode and multiplexed mode are defined in section 2.2.
The semantics of stdio mode are defined in [`vt6/term`](https://vt6.io/std/term/).

A VT6 client SHALL have access to a bidirectional byte stream, which is called this client's **standard input/output** and MUST start out in stdio mode.

A platform MAY define a method by which clients can gain access to further bidirectional byte streams.
Bidirectional byte streams obtained through this method MUST start out in message mode.

Bidirectional byte streams that are in message mode or multiplexed mode are called **server connections**.
When a client writes a byte string into a server connection, the same byte string MUST be received unaltered by this client's server.
When a client reads a byte string from a server connection, it SHALL have been sent by this client's server.
The server SHALL be able to distinguish between server connections opened by different clients, as well as different server connections opened by the same client.
This does not necessarily mean that the server can identify which server connection belongs to which client process, or which server connections correspond to the same client process.

*Rationale:* The server connection is separate from the standard input and output for scenarios where the VT6 client must be certain that the messages it sends are received by the VT6 server and not by another party (such as the next client in a shell pipe), and vice versa for server-to-client messages.
In POSIX, the server connection replaces the [special capabilities of terminal devices](https://linux.die.net/man/3/termios).

When something is defined as happening when a server connection is closed, that thing SHALL happen only when the bidirectional byte stream that is that server connection is closed, not when it switches out of message mode or multiplexed mode.

*Rationale:* This is an explicit clarification because the phrase "when a server connection is closed" could be misconstrued as also applying to when a server connection ceases to be a server connection (e.g. by switching from message mode into stdio mode).

### 1.3. Message types and properties

A **message type** is a name for a kind of message (see section 2) that can be sent on a server connection, either from client to server or vice-versa.
Each message type is defined by its name and a set of criteria describing when a message of that type is to be considered valid by the recipient.
These criteria include at least:

- the directionality (whether the message may be sent from a client to a server, or vice-versa, or both),
- the number of arguments that a message of this type may contain,
- the format and/or structure of said arguments,
- the behavior that is expected of the recipient party upon having received the message.

A **property** is a quantifiable aspect which describes the server, or the server connection over which messages concerning this property are exchanged.
Each concrete value of a property is represented as a `<byte-string>` (as defined in section 2).
The value of a property may influence how the server reacts to a message from the client.
It may also influence how the client reacts to a message from the server if (and only if) the client has subscribed to this property (see section 5.1).

Each property is defined by its name and at least the following criteria:

- the set of values that the property can have,
- whether, and under which circumstances, the client may update the property's value (see section 5.3),
- how the behavior of client and server is influenced by the value of this property.

For each message type, there SHALL NOT be a property of the same name.

*Rationale:* Even though technically possible, it would cause unnecessary confusion.

### 1.4. Modules

```abnf
letter     = %x41-5A / %x61-7A                  ; letters A-Z and a-z
identifier = ( letter / "_" ) *( letter / "-" / "_" )
```

The VT6 protocol is divided into **modules**.
Each module has a name which is accepted by `<identifier>`.
For example, this document concerns the module `core`.
When it is not clear from the context that a given identifier refers to a module name, the prefix `vt6/` may be prepended to it.

A module is considered **official** if its specifications are developed in the same location as this specification.
The name of any unofficial module MUST start with a leading underscore and SHOULD indicate the organization that is responsible for its specification.

A module is considered **private** if it is intended to be used by client and server implementations of a single vendor.
The name of any private module SHOULD start with two leading underscores.

*Rationale:* We strive to avoid name clashes between modules by different vendors, and reserve short module names for official modules to minimize message length for common messages.

Modules partition the VT6 protocol into parts which each may or may not be supported by a given server or client.
This includes, most prominently, message types and properties.

```abnf
scoped-identifier = identifier "." identifier
message-type      = "want" / "have" / "nope" / scoped-identifier
```

Modules act as namespaces for message types and properties.
Each message type or property name MUST be accepted by `<scoped-identifier>`, and the part before the dot MUST be equal to the name of the module defining it.
As an exception, the module "core" is allowed to define the message types "want", "have" and "nope" which do not contain a module name (see sections 4 and 5).

For example, the module `example` may define a message type named `example.foo` and a property named `example.bar`, but not a message type named `sample.foo` or a property named `sample.bar`.

### 1.5. Module versions

```abnf
digit   = %x30-39 ; decimal digits 0-9
nzdigit = %x31-39 ; non-zero decimal digits 1-9

version-number = "0" / ( nzdigit *digit )

major-version = version-number
minor-version = version-number
full-version  = major-version "." minor-version
```

Each module can have multiple **versions**.
Each module version has a **major version number** and a **minor version number**, as accepted by the `<major-version>` and `<minor-version>` grammar elements defined above.
When both version numbers are shown together, they are formatted as implied by the definition of the `<full-version>` grammar element defined above.

When referring to a module version in specifications and other documents, the recommended way is to append the full version number to the module name including the `vt6/` prefix.
For example, this document specifies version 1.0 of the module `core`, so the recommended identifier for this module version is `vt6/core1.0`.

Each module specification MUST clearly indicate the module name and full version number, preferably by including the recommended module version identifier in the document title, like this document does.

When the first specification of a module is created, its full version number MUST be set to `1.0`.
Everytime a module specification is changed, the module version MUST be adjusted as follows:

1. The minor version number is incremented.
2. Then, if the specification has been changed in a backwards-incompatible way compared to the previous release (see section 1.5), the major version number is incremented and the minor version number is reset to 0.

This requirement does not apply when the release is only a draft or pre-release that is not considered normative, and clearly labeled as such.

**Rationale:** This follows the basic notion of [semantic versioning](http://semver.org/spec/v2.0.0.html), albeit massively simplified to suit the usecase of module specifications.

Each module specification whose minor version number is bigger than 0 SHOULD indicate which parts of it have been added or changed compared to previous specifications of that module with the same major version number.

**Rationale:** Implementors should not have to `diff` specification documents manually.

### 1.6. Compatibility across module versions

The following changes to a module specification are considered **backwards-compatible**:

- addition of a new message type or property
- deprecation (but not removal) of an existing message type or property
- definition of previously undefined or underdefined behavior of an existing message type or property
- copyediting

Every other change to a module specification is considered **backwards-incompatible**, especially:

- removal of a message type or property
- change of behavior of an existing message type or property in such a way that there may exist programs that conform to the previous module version, but not to the current one

As an additional rule, all versions of the `core` module MUST be backwards-compatible with the parts of this specification that relate to all client and server behavior that takes place before a concrete version of the `core` module has been agreed to by the server (see section 3).
This includes, specifically:

- the parts of sections 1 and 2 that describe how client and server establish a connection to each other and use it to exchange messages, and
- the syntax of `want`, `have` and `nope` messages as described in sections 2 and 4.
  Those message types are therefore called **eternal**.

### 1.7. Platform integration modules

Each platform is defined by a **platform integration module**, which is a VT6 module.

For each official module that references **platform-specific behavior**, any module version of a platform integration module MUST define said behavior for its platform, or it MUST define that the module referencing platform-specific behavior is not supported on its platform.
This does not apply for platform-specific behavior that is first described in module versions released after the module version in question of the platform integration module.

A platform integration module MAY define message types and properties which are only available on the platform defined by it.

*The remainder of this section is non-normative.*

The following platform integration modules are available at the time of publication of this document:

- [vt6/posix](../../posix/) for operating systems that implement the POSIX specification

## 2. Messages

### 2.1. Syntax

#### 2.1.1. Byte strings

```abnf
byte   = %x00-FF ; any single byte
length = "0" | nzdigit *digit

byte-string = length ":" *byte ","
```

In the context of VT6 messages, a **byte string** is a sequence of bytes such that:

- it is accepted by `<byte-string>`, and
- the number of bytes between the first colon and the trailing comma is equal to the decimal value of the sequence of ASCII digits before the first colon.

The sequence of bytes between the first colon and the trailing comma is called the **value** of the byte string.

*Rationale:* This is the [netstring encoding](https://cr.yp.to/proto/netstrings.txt) first described by Daniel J. Bernstein.

#### 2.1.2. Messages

```abnf
message = "{" length "|" 1*byte-string "}"
```

A **VT6 message** (or just **message**, if the term is not ambiguous) is a nonempty sequence of byte strings, such that:

- it is accepted by `<list>`,
- the number of byte strings in the sequence after the first pipe symbol is equal to the decimal value of the sequence of ASCII digits before the first pipe symbol, and
- the value of the first byte string is accepted by `<message-type>`.

The first byte string in a message is therefore called the message's **type**.
Any following byte strings are called the message's **arguments**.
A message may have arbitrarily many arguments, including zero arguments.

*Rationale:* We avoid compactly-coded escape sequences like those specified by [ECMA-48](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-48,%202nd%20Edition,%20August%201979.pdf) aka ANSI&nbsp;X3.64 aka ISO/IEC&nbsp;6429 because of the risk that escape sequences specified by different modules collide with each other.
We choose an adaptation of the netstring format because it can be implemented very easily, both on the generating and on the parsing side.
We use different sigils for argument lists (the pipe symbol) and byte strings (the colon symbol), so that the syntax can later be expanded to allow for nested lists.
The curly brackets that enclose messages serve as a sequence point where parsing can be resumed after a parsing error (see section 2.3).

#### 2.1.3. Human-readable representation

The following alternative representation for byte strings and messages may be used when showing messages in specifications or informational displays, such as logs:

- Byte strings whose value matches the regular expression `^[A-Za-z0-9._-]*$` are represented directly by their value.
- Other byte strings are represented as C string literals with the same value.
- Messages are represented by a whitespace-separated concatenation of the representations of the byte strings contained in it, enclosed in parentheses.

*Rationale:* This format is much more human-readable and thus better suited for examples within specifications, or for diagnostic output of programs that process VT6 messages.

For example, a human-readable representation of the message `{3|8:core.set,13:example.title,11:hello "world",}` is `(core.set example.title "hello \"world\"")`.

#### 2.1.4. Message streams

```abnf
message-stream = *( *space message ) *space
```

A **VT6 message stream** (or just **message stream**, if the term is not ambiguous) is a sequence of VT6 messages which are optionally preceded, succeeded and/or separated by whitespace.

*Rationale:* Allowing for whitespace between messages is especially useful when messages are emitted by a script in a language where a `print` operation appends a line separator by default.

### 2.2. Server-client communication

#### 2.2.1. Message mode

When a VT6 client has a method of obtaining bidirectional byte streams in message mode (see section 1.1), it can send messages to its server by writing a message stream into one of these streams, and receive replies from the server by reading a message stream from the same stream.

#### 2.2.2. Entering multiplexed mode

*Rationale:* Multiplexed mode is intended for clients which only have a single bidirectional byte stream to their server and have no direct way of establishing separate server connections.
The most prominent example of this is a client connected via a remote login protocol such as [SSH](https://tools.ietf.org/html/rfc4251).
Most clients will not need to implement multiplexed mode.
The remote login provider (e.g. the SSH server) should be connected to a muxer to provide the remote clients with a proper VT6 server.

A client can attempt to upgrade its standard input/output from stdio mode into multiplexed mode with the following procedure:

*Rationale:* The upgrade is available to all clients, even those who have a method of obtaining server connections.
This simplifies the server implementation since the server does not have to distinguish which clients have such a method and which don't.

1. The client writes the magic string `<ESC>[6V` (decimal byte sequence 27, 91, 54, 126) into standard output.
2. Once the client reads the same magic string from standard input, the standard input/output has switched to multiplexed mode.
3. If, while waiting for this magic string, the client instead observes the magic string `<ESC>[0V` (decimal byte sequence 27, 91, 48, 126) on standard input, the upgrade to multiplexed mode has failed and the standard input/output remains in stdio mode.
   The client SHALL assume that a VT6 server is not present (as defined in section 1.1), and it SHALL NOT attempt to upgrade to multiplexed mode using this procedure ever again.

*Rationale:* The magic strings used in this procedure are valid (and, to our knowledge, unallocated) ANSI escape sequences, so it should just be ignored by legacy terminals that are not VT6 servers.
The server must reply with the same magic string for two reasons: as an additional check that the server is really VT6-capable and not just a legacy terminal, and to provide an explicit sequencing point after which the client has to apply the multiplexing rules to stdin.
The server may have written to the client's stdin after the client has sent the magic string, but before the server received it; the explicit magic string allows the client to distinguish that.
Point 3 allows legacy terminals to unblock clients waiting for a protocol upgrade that won't come.

A server that receives the magic string `<ESC>[6V` over a bidirectional byte stream in stdio mode SHALL immediately answer with either `<ESC>[6V` or `<ESC>[0V` on the same bidirectional byte stream, and afterwards consider the stream to be in multiplexed mode if it sent `<ESC>[6V`.

When standard input/output is transmitted over the network, the transport protocol SHOULD indicate early whether the terminal is VT6-capable, and the transport-level program on the side of the client SHOULD send `<ESC>[0V` into the client's standard input if it knows that the terminal is not VT6-capable.

*Rationale:* This avoids an additional network round-trip for an upgrade procedure that is known to fail.

#### 2.2.3. Multiplexed mode

When a VT6 client has access to a bidirectional byte stream in multiplexed mode, it can send messages to its server by writing fenced message streams into it, and receive replies from the server by reading fenced message streams from it.
A message stream is **fenced** when it is preceded by one ESC byte (decimal value 27) and succeeded by another ESC byte, and all ESC bytes that occur in the message stream are escaped by doubling them.

Any byte strings written into a bidirectional byte stream in multiplexed mode which are not part of a fenced message stream SHALL be interpreted by the recipient as if they had been written into that bidirectional byte stream in that same direction while it was in stdio mode.
In other words, the client can write standard output into the bidirectional byte stream directly, inbetween fenced message streams, and the server can conversely send standard input to the client by writing into the bidirectional byte stream directly, inbetween fenced message streams.
As an exception, all ESC bytes that are part of the byte strings thus transferred MUST be escaped by doubling them.

### 2.3. Invalid messages, and handling thereof

A message is **invalid** if...

- it does not conform to the definitions above,

- the message's arguments do not conform to the requirements for the message's type, as stated in the specification defining the message type in question,

- the length of the message exceeds the recipient's maximum message size (see sections 6.1 and 6.2), usually 1024 bytes, or

- the message type is unknown or its use has not been agreed to by the server (see section 3).

Receipt of an invalid message MUST NOT cause any effect (besides error responses, see section 4.1) that can be observed by the sender.

If, while parsing a message stream, a recipient finds a message that cannot be parsed (either because of syntax errors or because the message exceeds the recipient's maximum message size), the recipient SHOULD employ the following algorithm to reset the stream parser and find the next well-formed message.

1. Discard all input characters until a `{` character is found.
2. Try to parse a message starting from this character.
3. If no valid message could be read, go back to step 1.

### 2.4. Predefined property types

When a property is said to **accept string values**, this means that the set of acceptable values for this property is the set of all byte strings whose value is a properly UTF-8-encoded string.

*Rationale:* [utf8everywhere.org](http://utf8everywhere.org) nicely sums up the arguments for not bothering with other text encodings.

```abnf
integer          = "0" / ( [sign] nzdigit *digit )
unsigned-integer = "0" / ( nzdigit *digit )

sign = "+" / "-"
```

When a property is said to **accept integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<integer>` grammar element defined above.
Analogously, when a property is said to **accept unsigned integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<unsigned-integer>` grammar element defined above.

In both these cases, the **numerical value** of each such byte string is the decimal value of the sequence of digits in the byte string's value.
The module specification defining the property may impose additional restrictions on the numerical value of the property.

Section 6 of this specification uses the property types defined in this section.
Other module specifications which use some or all of the property types defined in this section SHALL reference this section.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document uses the predefined property types from section 2.4 of `vt6/core1.0`.

## 3. Protocol negotiation

Before a client can use the message types and properties of a module, usage of the module must have been agreed to by the server.
A server **agrees to** using a module by answering a `want` message from the client with a corresponding `have` message.

### 3.1. The `want` message

- Directionality: client to server
- Number of arguments: two or more

A client can send a `want` message to the server to request usage of a module.
The first argument MUST be the module name, and the remaining arguments SHALL be the major versions of that module that the client supports.
Each major version MUST be formatted according to the `<major-version>` grammar element defined above.
For example, the following `want` message indicates that the client wants to use either major version 1 or major version 2 of the `example` module.

```vt6
(want example 1 2)
```

The first message that a client sends on each server connection MUST be a `want` message requesting the `core` module.

*Rationale:* All other modules depend on the definitions in `core`, so it must be negotiated first.

### 3.2. The `have` message

- Directionality: server to client
- Number of arguments: zero or two

Upon receiving a valid `want` message, the server MUST reply with a `have` message to indicate if it agrees to using the requested module.
If the `want` message is valid, but the server does not agree to the requested module, it MUST reply with a `have` message with zero arguments.

If the server agrees to using the requested module, it MUST reply with a `have` message with two arguments: the module name and the module version supported by the server.
Receipt of this `have` message entitles the client to use all message types, properties and behavior defined in that module version, or one with the same module name, same major version number and a smaller minor version number.
The module version MUST be formatted according to the `<full-version>` grammar element defined above.
The major version contained therein MUST be one of the major versions that appeared in the original `want` message.

The server MUST NOT agree to using a module if it does not support any of the major versions of that module which were offered in the `want` message.
The server MUST NOT agree to using multiple major versions of the same module across multiple `have` messages on the same server connection.
The server MAY agree to using different major versions of the same module on different server connections.

When a `want` message concerns the same module as an earlier `want` message, the server MUST reply consistently.
If it agreed to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST agree to this major version and offer the same full version as in the earlier `have` message.
If it did not agree to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST NOT agree to this major version.

The following snippet shows examples of streams of `want` messages and `have` replies.
Each set of messages, as separated by an empty line, is to be considered as occurring on separate server connections.

```vt6
(want core 1)
(have core 1.0)
(want foo 2)
(have foo 2.3)
--> client can now use core1.0 module and either foo2.0, foo2.1, foo2.2 or foo2.3 module

(want core 1 2)
(have core 2.1)
--> client can now use either core2.0 or core2.1 module, but not core1.x modules

(want core 1)
(have core 1.0)
(want foo 1 2)
(have)
--> server did not agree to using foo module
```

The server is under no obligation of agreeing to any module.
Clients should be prepared to gracefully handle unavailable modules.
If the client finds that the server has not agreed to a module that the client needs, it must exit.

## 4. Other eternal message types

### 4.1. The `nope` message

- Directionality: any
- Number of arguments: none

Upon receiving an invalid message, a server or client MAY reply by sending a `nope` message with no arguments.
It MUST do so if:

1. it cannot determine the message type of the invalid message, or
2. it can determine, based on the message type of the invalid message, that the sender is waiting for a reply.

As an exception, the recipient SHALL NOT send a `nope` message when a module that the server has agreed to mandates a different behavior for the invalid message in question.

*Rationale:* The purpose of the `nope` message is solely to unblock any processes which are waiting for a reply to their previous message.
This module does not define any generic error reporting mechanisms beyond this message type.
We consider it pointless to try to get any misbehaving process to start behaving correctly by pointing out their errors to them.

## 5. Message types for `vt6/core1.0`

### 5.1. The `core.sub` message

- Directionality: client to server
- Number of arguments: one

A client can send a `core.sub` message to establish a **subscription** to a property.
The argument is the name of that property.

*Rationale:* It is intentional that subscribing to a property is the only way for a client to retrieve a property's value.
This design nudges implementors towards handling server-initiated changes to properties properly.

A `core.sub` message is invalid (within the meaning of section 2.3) if its argument is not the name of a property, or if it is defined by a module or module version to whose usage the server has not agreed.

When a server receives a valid `core.sub` message, it MUST subscribe the sending client to the specified property, and immediately notify the client with a corresponding `core.pub` message (see below).

### 5.2. The `core.pub` message

- Directionality: server to client
- Number of arguments: two

A server can send a `core.pub` message to inform a client of the value of a property.
The first argument SHALL be the name of a property.
The second argument SHALL be the value of that property.

A `core.pub` message is invalid (within the meaning of section 2.3) if its first argument is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed, or
- the name of a property to which the recipient of the `core.pub` message has not subscribed.

Moreover, a `core.pub` message is invalid if its second argument is not a valid value for the property in question according to the specification defining the property.

A `core.pub` message can be sent by the server at any time to notify the client of changes to the values of a property that the client has subscribed to.
Upon receiving a valid `core.sub` or `core.set` message, the server MUST reply immediately with a `core.pub` message for the same property.

### 5.3. The `core.set` message

- Directionality: client to server
- Number of arguments: two

A client can send a `core.set` message to change the value of a property.
The argument list of a `core.set` message has the same form as that of a `core.pub` message (a pair of property name and value).

A `core.set` message is invalid (within the meaning of section 2.3) if its argument is not the name of a property, or if it is defined by a module to whose usage the server has not agreed.

The message is *not* invalid if the second argument is a value that is not permissible for the property in question, and the message is otherwise valid.

*Rationale:* For non-trivial properties, the client might not have enough information to decide whether a given value is valid.

A client's request to change the value of a property does not imply any obligation of the server to comply with this request.
The server may refuse to change the property's value at all (especially if the property is read-only), it may comply with the request, or set the property to an entirely different value, as long as the value is valid according to the property's specification.
This is why a `core.pub` message is sent as a reply for a `core.set` message.
The client SHOULD observe the `core.pub` reply to learn whether the requested changes were accepted.

*Rationale:* For example, consider the case of the client trying to set `core.client-msg-bytes-max` to a larger value.
The server might reject this, and report the previous value in the `core.pub` response; or it might choose a value inbetween the previous and the requested value because it absolutely cannot process messages larger than that.

### 5.4 The `core.to-stdio` message

*Rationale:* This message allows a shell or other client-spawning client to obtain separate standard input/output channels for new clients.

- Directionality: both
- Number of arguments: zero

Upon receiving a valid `core.to-stdio` message, a server MUST reply with an identical message on the same server connection.
After this exchange, that bidirectional byte stream switches from message mode into stdio mode.
All bytes that flow through it (in either direction) after the trailing `}` of the `core.to-stdio` message SHALL be interpreted according to the rules for stdio mode.

Messages of this type are invalid when transmitted over a bidirectional byte stream in multiplexed mode.

## 6. Properties for `vt6/core1.0`

### 6.1. The `core.server-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the server to the client in bytes.
The default value of this property MUST NOT be larger than 1024.

*Rationale:* The upper limit is important because clients are therefore assured that a 1 KiB buffer can hold any single message sent by the server, unless a different limit is negotiated.
We choose this standard buffer size of 1 KiB such that most, if not all, messages that ever need to be sent fit into this buffer, without wasting too much memory on buffers.

### 6.2. The `core.client-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the client to the server in bytes.
The default value of this property MUST NOT be smaller than 1024.

*Rationale:* The lower limit is important because clients are therefore assured that any messages smaller than 1 KiB will be accepted by any server, unless a different limit is negotiated.
The rationale from section 6.1 applies respectively.

The client MUST observe the server response when setting this property, because the server may reject the new property value or choose a compromise value.
