<!-- draft -->
# `vt6/core1.0` - Fundamental protocols and interface contracts

This document specifies version `1.0` of the VT6 module `core`.
Refer to this document using the identifier `vt6/core1.0` or its canonical URL <https://vt6.io/std/core/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## 1. Definitions and platform requirements

The VT6 protocol is divided into **modules**.
A process which implements VT6 modules and exposes them to other processes is called a **VT6 server**.
A process that consumes this functionality is called a **VT6 client**.
A process that acts both as a VT6 client to at least one process and as a VT6 server to at least one process at the same time is called as **VT6 proxy**.

*Rationale:* In the most common setup (programs being started by a shell inside a terminal emulator), the terminal emulator acts as the server.
The shell and the programs started by it are the clients.

A **platform** is an operating environment which is admissible for VT6 clients and/or servers.

A platform for VT6 servers SHALL define how a server can launch other processes which can then act as VT6 clients, or it alternatively SHALL define a method for the server to delegate this task to other processes.

A **bidirectional text stream** is an object from which byte strings can be read and into which byte strings can be written.
A VT6 client SHALL have access to a bidirectional text stream, which is called this client's **standard input/output**.

A platform MAY define a method by which clients can gain access to further bidirectional text streams.
Text streams obtained through this method are called **server connections**.
When a client writes a byte string into a server connection, it MUST NOT be received by any process but this client's server.
When a client reads a byte string from a server connection, it SHALL have been sent by this client's server.
The server SHALL be able to distinguish between server connections opened by different clients, as well as different server connections opened by the same client.
This does not necessarily mean that the server can identify which server connection belongs to which client process.

*Rationale:* The server connection is separate from the standard input and output for scenarios where the VT6 client must be certain that the messages it sends are received by the VT6 server and not by another party (such as the next client in a shell pipe), and vice versa for server-to-client messages.
In POSIX, the message input and output replace the [special capabilities of terminal devices](https://linux.die.net/man/3/termios).

If the platform allows VT6 client processes to be started while a VT6 server is not present, the platform MUST define a method for client processes to determine whether a VT6 server is present.
If no VT6 server is present, the client process SHALL not be considered a VT6 client for the purpose of this specification, and any other specifications that inherit the meaning of the term "VT6 client" from it.

If a VT6 client has a method to obtain server connections, it is said to be operating in **normal mode**.
Otherwise, it is said to be operating in **multiplexed mode**.

*Rationale:* The multiplexed mode is intended for clients which only have a single bidirectional text stream to their server and have no way of establishing a separate bidirectional text stream to use as a server connection.
The most prominent example of this is a client connected via a remote login protocol such as [SSH](https://tools.ietf.org/html/rfc4251).

### 1.1. Platforms

A platform is defined by a *platform integration module*, which is a VT6 module (see section 3).

For each official module (see section 3.3) that references platform-specific behavior, the specification for each platform integration module MUST define said behavior for its platform, or it MUST define that the module referencing platform-specific behavior is not supported on its platform.

A platform integration module MAY define message types, properties and capabilities (see section 3) which are only available on the platform defined by it.

*The remainder of this section is non-normative.*

The following platform integration modules are available at the time of publication of this document:

- [posix1](../posix1/) for operating systems that implement the POSIX specification

## 2. Messages

This section uses augmented Backus-Naur form (ABNF) as defined in [RFC5234](https://tools.ietf.org/html/rfc5234).

### 2.1. S-expression format

```abnf
s-expression    = "(" *space *( ( s-expression / atom ) *space ) ")"

atom            = bareword / quoted-string

bareword        = 1*( letter / digit / "." / "-" / "_" )

quoted-string   = quote *( quoted-char / bslash ( bslash / quote ) ) quote

quote   = %x22              ; " (double quote)
bslash  = %x5C              ; \ (backslash)
digit   = %x30-39           ; decimal digits 0-9
nzdigit = %x31-39           ; non-zero decimal digits 1-9
letter  = %x41-5A / %x61-7A ; letters A-Z and a-z
space   = %x20 / %x09-0D    ; ASCII characters which are accepted by isspace() under the C locale
```

Furthermore, the `<quoted-char>` element accepts all byte strings which encode exactly one Unicode character using the UTF-8 encoding, except for the ASCII backslash or the ASCII double quote.

An **s-expression** is a parenthesis-delimited sequence of atoms or other s-expressions, which are referred to as the s-expression's **elements**.
Whitespace (sequences of `<space>`) between the parentheses and atoms is ignored.
For example, the following three s-expressions are equivalent.

```vt6
(foo bar)

(           foo bar)

(foo   bar   )
```

The **length** of an s-expression is the number of elements that it contains.
Any element that is an s-expression itself counts as one element regardless of how many elements it contains.
For example, the length of the s-expression `(a (b c) d)` is 3.
The shortest s-expression is the empty s-expression, `()`, with length 0.

An **atom** is either a bareword or a quoted string.
Each atom **represents** a string of Unicode characters.

A **bareword** is a sequence of ASCII letters, digits, dots, dashes or underscores, such that the first character is a letter.
A bareword **represents** itself.

```
bareword             valid
example-bareword     valid
example3.0           valid
example bareword     invalid (contains whitespace)
5example             invalid (does not start with letter)
"bareword"           invalid (contains forbidden ASCII character)
¯\_(ツ)_/¯           invalid (contains character not in ASCII)
```

A **quoted string** is a string of printable Unicode characters in the UTF-8 encoding, except for the double quote or backslash, enclosed by double quotes.
The quoted string **represents** the string of characters between its enclosing quotes, except for escaping rules as noted below.
For example, the quoted string `"abc"` represents the same 3-letter string as the bareword `abc`.

A quoted string may represent a string containing double quotes or backslashes, if these characters are escaped by inserting a backslash before them.
For example, the quoted string `"ab\\\"cd\""` represents the string `ab\"cd"`.
For each string of Unicode characters, there exists exactly one quoted string that represents it.

*Rationale:* We avoid compactly-coded escape sequences like those specified by [ECMA-48](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-48,%202nd%20Edition,%20August%201979.pdf) aka ANSI&nbsp;X3.64 aka ISO/IEC&nbsp;6429 because of the risk that escape sequences specified by different modules collide with each other.
We choose s-expressions because they can be implemented very easily, both on the generating and on the parsing side.
They are as flexible and human-readable as JSON, TOML or YAML, but at the same time more compact than either of those.
We do not include support for additional escape sequences in quoted strings because there is no apparent need for them.
Users generating s-expressions will be using a programming or scripting language, and can take advantage of the escape sequences provided by these languages' string literals.
Each s-expression adhering to this specification is also a valid UTF-8-encoded string, so implementations can reuse existing Unicode support libraries.

### 2.2. Message format

```abnf
version-number  = "0" / ( nzdigit *digit )
strict-bareword = ( letter / "_" ) *( letter / "-" / "_" )

module-name    = strict-bareword version-number ; major version number only

scoped-name    = module-name "." strict-bareword
message-type   = "want" / "have" / scoped-name

message        = "(" *space message-type *space *( ( s-expression / atom ) *space ) ")"
```

A **VT6 message** (or just **message**, if the term is not ambiguous) is a nonempty s-expression whose first element is an atom that is accepted by `<message-type>`.
The first element of a message is therefore called the message's **type**.
Any following elements of a message are called the message's **arguments**.
A message may have arbitrarily many arguments, including zero arguments.
As can be seen in the grammar definition above, a message type name consists of a module name (see section 3.1) and a strict bareword, separated by a dot (see section 3.3).
As an exception, the message types named "want" and "have" do not contain a module name (see section 4).

```abnf
message-stream = *( *space message ) *space
```

A **VT6 message stream** (or just **message stream**, if the term is not ambiguous) is a sequence of VT6 messages which are optionally preceded, succeeded and/or separated by whitespace.

*Rationale:* Allowing for whitespace between messages is especially useful when messages are emitted by a script in a language where a `print` operation appends a line separator by default.
As with s-expressions above, a message stream is also a valid UTF-8-encoded string, so implementations can reuse existing Unicode support libraries.

```abnf
fenced-message-stream = escape-char message-stream escape-char

escape-char = %x1B
```

A message stream is **fenced** when it is preceded by one ESC character and succeeded by another ESC character.

### 2.3. Server-client communication

When a VT6 client is running in normal mode, it sends messages to its server by writing a message stream into a server connection, and receives messages from the server by reading a message stream from the same server connection.
Furthermore, it can read input data from standard input and write output data to standard output.
This specification does not restrict the form of these input and output data.

When a VT6 client is running in multiplexed mode, it sends messages to its server by writing a *fenced* message stream onto the standard output.
Any ESC character that is part of the output data or of a message inside the fenced message stream must be escaped by doubling it.

Conversely, a VT6 client running in multiplexed mode receives messages from its server by reading a *fenced* message stream from the standard input, whenever a single ESC character is encountered.
Any two consecutive ESC characters SHALL be interpreted as a single ESC character in the input data or in the current message.

A VT6 client running in multiplexed mode MUST write the magic string `<ESC>[6V` (decimal byte sequence 27, 91, 54, 126) into the standard output before writing anything else.
The magic string is not considered to be part of the output data nor does it start a fenced message stream, so the escaping rule for ESC characters stated above does not apply.

If the client fails to do so, all data written by the client into its standard output MUST be considered output data and the escaping rule for ESC characters does not apply.
Furthermore, fenced message streams MUST NOT be written into the client's standard input, and the escaping rule for ESC characters does not apply to the input data written into it, either.

### 2.4. Invalid messages, and handling thereof

A message is **invalid** if...

- the message is not accepted by `<s-expression>`,

- the message's first element is not an atom accepted by `<message-type>`,

- the message's arguments do not conform to the requirements for the message's type, as stated in the specification defining the message type in question,

- the size of the bytestring encoding the message exceeds the recipient's maximum message size (see sections 6.1 and 6.2), usually 1024 bytes, or

- the message type is unknown or its use has not been agreed to by the server (see section 4).

A VT6 server receiving an invalid message from a VT6 client MUST act towards the client as if the message had never been received at all, and vice versa for messages from the server to the client.

A VT6 client or server MAY continue parsing and acting on a partially received message only if it is able to rollback all actions performed because of this message if the message turns out to be invalid once fully received, or if the connection is lost before the message is fully received.
This only concerns actions that are performed towards the sender of the message.
For example, the action of a server reporting a malformed client message to the user is not restricted by this rule, since the action is towards the user rather than the VT6 client.

If, while parsing a message stream, a message in the stream exceeds the recipient's maximum message size, the recipient SHOULD employ the following algorithm to reset the stream parser and find the next well-formed message.

1. Discard all input characters until a `(` character is found, without keeping track of whether the `(` is inside a quoted string or not.
2. Try to parse a message starting from this character.
3. If no valid message could be read, go back to step 1.

*Rationale:* In step 1, we explicitly recommend to ignore quotes because, given the simple syntax of s-expressions, the most likely syntax error (other than unbalanced parentheses) is malformed quoted strings because of unescaped quotes or backslashes.

## 3. Modules

The VT6 protocol specification is divided into **modules**, each of which MUST have a **name** which is accepted by `<module-name>` (see section 2.2).
For example, this document specifies the `core1` module.

Each module contains the message types, properties and capabilities defined in its specification (see below).
Each message type MUST have a **name** which is accepted by `<message-type>` (see section 2.2).
Each property or capability MUST have a **name** which is accepted by `<scoped-name>` (see section 2.2).

For each message type, property and capability (except for the `want` and `have` message types defined in section 4), the part of its name before the dot MUST be equivalent to the name of the module whose specification defines it.
For example, a module with a name of `example2` may define a message type named `example2.foo` and a property named `example2.bar`, but not a message type named `example1.foo` or a property named `sample2.bar`.

Each **message type** is defined by its name and a set of criteria describing when a message whose first element is the message type's name is to be considered valid by the recipient.
These criteria include at least:

- the directionality (whether the message may be sent from a client to a server, or vice-versa, or both),
- the capabilities that the server must agree to (see section 4) before messages of this type may be sent, if any,
- the number of arguments that a message of this type may contain,
- the format and/or structure of said arguments,
- the behavior that is expected of the recipient party upon having received the message.

A **property** is a quantifiable aspect which describes the server or the server connection over which messages concerning this property are exchanged.
Each concrete value of a property is represented as either an `<atom>` or an `<s-expression>`.
The value of a property may influence how the server reacts to a message from the client.
It may also influence how the client reacts to a message from the server if (and only if) the client has subscribed to this property (see section 5.1).

Each property is defined by its name and at least the following criteria:

- the set of values that the property can have,
- the capabilities that the server must agree to before the client may subscribe to this property (see section 4),
- whether, and under which circumstances, the client may set the property's value (see section 5.3),
- how the behavior of client and server is influenced by the value of this property.

A **capability** is an aspect of the module specification that may not be supported by every server.
The server therefore has to agree to a capability (see section 4) before client and server can use the message types, properties or other behaviors restricted to this capability, even if the usage of the module which contains them has already been agreed to by the server.

For each object (message type, property or capability) in a module, that module SHALL NOT contain a different object of the same name.

*Rationale:* Even though technically possible, it would cause unnecessary confusion if, for example, there were a message type with the same name as a property.

### 3.1. Module versions

Each module name, as accepted by the `<module-name>` grammar element defined above, has a trailing positive integer.
This number is the **major version** of this module's specification.
The module also has a second version number, also a positive integer, which is called **minor version** and is not part of the module name.

When a new module specification is created, its major and minor version number MUST be set to 1 and 0, respectively.
A module specification MUST clearly indicate its major and minor version number.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document specifies version `<major-version>.<minor-version>` of the VT6 module `<module-name-without-major-version>`.
> Refer to this document using the identifier `vt6/<module-name>.<minor-version>` or its canonical URL `<stable-url-to-module-spec>`.

Everytime a new release of the module specification is made, its version number MUST be adjusted as follows:

1. The minor version number is incremented.
2. If the module specification has been changed in a backwards-incompatible way compared to the previous release, the major version number is incremented and the minor version number is reset to 0.

This requirement does not apply when the release is only a draft or pre-release that is not considered normative, and clearly labeled as such.

**Rationale:** This follows the basic notion of [semantic versioning](http://semver.org/spec/v2.0.0.html), albeit massively simplified to suit the usecase of module specifications.

Each module specification whose minor version number is bigger than 0 SHOULD indicate which parts of it have been added or changed compared to previous specifications of that module with the same major version number.

**Rationale:** Implementors should not have to `diff` specification documents manually.

### 3.2. Compatibility across versions

The following changes to a module specification are considered **backwards-compatible**:

- definition of a new message type, property or capability
- deprecation (but not removal) of an existing message type, property or capability
- definition of previously undefined or underdefined behavior of an existing message type, property or capability
- copyediting

Every other change to a module specification is considered **backwards-incompatible**, especially:

- removal of a message type, property or capability
- change of behavior of an existing message type, property or capability in such a way that there may exist programs that conform to the previous version of the specification, but not to the current one

As an additional rule, all versions of the `core` module (i.e., any version of `core1`, `core2`, `core3`, and so on) MUST be backwards-compatible with the parts of this specification that relate to all client and server behavior that takes place before a concrete version of the `core` module has been agreed to by the server.
This includes, specifically:

- the parts of sections 1 and 2.3 that describe how client and server establish a connection to each other and use it to exchange messages, and
- the syntax of `want` and `have` messages as described in sections 2.1 and 4.

The backwards-compatibility requirement across major versions of `core` does not apply to those parts of the message syntax that can only be used after the initial `want` and `have` messages (namely, quoted strings and nested s-expressions).

### 3.3. Module naming conventions

A module is considered **official** if its specifications are developed in the same location as this specification.
The name of any unofficial module MUST start with a leading underscore and SHOULD indicate the organization that is responsible for its specification.

A module is considered **private** if it is intended to be used by client and server implementations of a single vendor.
The name of any private module SHOULD start with two leading underscores.

*Rationale:* We strive to avoid name clashes between modules by different vendors, and reserve short module names for official modules to minimize message length for common messages.

### 3.4. Predefined property types

```abnf
integer          = "0" / ( [sign] nzdigit *digit )
unsigned-integer = "0" / ( nzdigit *digit )

sign = "+" / "-"
```

When a property is said to **accept integer values**, this means that the set of acceptable values for this property is the set of all atoms whose string value matches the `<integer>` grammar element defined above.
Analogously, when a property is said to **accept unsigned integer values**, this means that the set of acceptable values for this property is the set of all atoms whose string value matches the `<unsigned-integer>` grammar element defined above.

In both these cases, the numerical value of each such atom is that value which is returned when the `atoll()` function as defined in [the POSIX.1 specification](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoll.html) is applied to the string value of the atom.
The module specification defining the property may impose additional restrictions on the numerical value of the property.

```abnf
boolean = "true" / "false"
```

When a property is said to **accept boolean values**, this means that the set of acceptable values for this property is the set of all atoms whose string value matches the `<boolean>` grammar element defined above.

Section 6 of this specification uses the property types defined in this section.
Other module specifications which use some or all of the property types defined in this section SHALL reference this section.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document uses the predefined property types from section 3.4 of the `vt6/core1.0` specification.

## 4. Protocol negotiation

Before a client can use the message types, properties and capabilities of a module, usage of the module must have been agreed to by the server.
Moreover, if some message types, properties and behaviors of a module are restricted to servers supporting a specific capability, the client can only use those message types, properties and behaviors after the server has agreed to using the capability.
A server **agrees to** using a module or capability by answering a `want` message from the client that mentions this module or capability with a `have` message that mentions this module or capability.

### 4.1. The `want` message

- Directionality: client to server
- Required capabilities: none
- Number of arguments: one or more

Each argument MUST be a bareword.
Quoted strings are not allowed in this message.

*Rationale:* The syntax of the `want` message is deliberately minimized because of the compatibility requirements in section 3.2.

The `want` message informs the server of modules and capabilities that the client wants to use.
Each argument is a module name as accepted by `<module-name>`, or a capability name as accepted by `<message-type>`, except for `want` and `have`.
For each argument that is a capability name, the server MUST already have agreed to using the module that defines this capability.
Alternatively, one of the arguments that comes before this argument MUST be that module's name.

The first message that a client sends MUST be a `want` message, and the argument list MUST start with at least one version of `core` (i.e., any of `core1`, `core2`, `core3`, and so on).

*Rationale:* All other modules depend on the definitions in `core`, so it must be negotiated first.

A `want` message may contain multiple versions of the same module name.
For example, the following `want` message indicates that the client can use (at least) two different versions of the `core` module, but only one version of the `foo` module.

```vt6
(want core1 core2 foo1)
```

### 4.2. The `have` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: zero or more

Each argument MUST be a bareword.
Quoted strings are not allowed in this message.

*Rationale:* Same as in section 4.1.

Upon receiving a valid `want` message, the server MUST reply with a `have` message to indicate which modules and capabilities in that `have` message it agrees to.
If it does not agree to any of the modules and capabilities requested, it MUST reply with a `have` message with zero arguments.
If the `want` message is invalid, it MUST also reply with a `have` message with zero arguments, except if the server has already agreed to a version of `core`, in which case the error handling mechanisms defined by said version of `core` apply (regarding `core1`, see section 5.4).

*Rationale:* A client will typically wait for the `have` reply because the validity of subsequent messages depends on it.
A missing `have` message might therefore stall the client forever.

Each argument in the `have` message corresponds to an argument in the `want` message, except that modules and capabilities to which the server does not agree are omitted.
This particularly means that the argument list of the `have` message MUST preserve the order of arguments in the `want` message.
From this and the definition of the `want` message also follows that the use of a module must be agreed to before any of its capabilities can be agreed to.

For `want` arguments that are capability names, the corresponding `have` argument is the same string, the capability name.
A server SHALL NOT agree to using a capability if it has not previously agreed to using the module defining said capability, unless it agrees to using the module in the same `have` message.

For `want` arguments that are module names, the corresponding `have` argument is the module name, with a dot and a positive integer appended to it.
The positive integer indicates the maximal minor version of this module that is understood by the server.
Receipt of the `have` message containing this argument entitles the client to use all message types, properties and capabilities defined in the specification of that module with the same major version number and the same, or a smaller, minor version number.

The server MUST NOT agree to using multiple major versions of the same module, neither in a single `have` message or across multiple `have` messages for the same client.
The server MAY agree to using different major versions of the same module with different clients.

If a module specification states that its module or a capability within that module **DEPENDS ON** another module or capability, the server MUST NOT agree to using this module or capability unless it has already agreed to using the dependency or does so in the same `have` message.
The recommended way to do so is by using the word "DEPENDS ON" in the way defined by this paragraph, and including the following sentence near the start of the specification:

> The keyword "DEPENDS ON" in this document is to be interpreted as described in section 4.2 of the `vt6/core1.0` specification.

The following snippet shows examples of valid and invalid pairs of `want` messages and `have` replies.
The snippet is not a single message stream.
Each pair of messages is to be considered individually.

```vt6
(want foo1 bar2)
(have foo1.0 bar2.3)
--> valid; client can now use foo1.0 module and either bar2.0, bar2.1, bar2.2 or bar2.3 module

(want foo1 foo2)
(have foo2.1)
--> valid; client can now use either foo2.0 or foo2.1 module, but not foo1.x modules

(want foo1.cap)
(have)
--> "want" is invalid; cannot negotiate capability from foo1 before foo1 module has been agreed upon

(want foo1 foo1.cap)
(have foo1.0)
--> valid; server has not agreed to capability

(want foo1 foo1.cap)
(have foo1.0 foo1.cap)
--> valid; server has agreed to capability

(want foo1 foo1.cap)
(have foo1.cap foo1.0)
--> "have" is invalid; argument order must match "want" message

(want foo1 bar1 foo1.cap)
(have foo1.0 foo1.cap)
--> valid; some modules not agreed to, but argument order is preserved

(want foo1 bar1)
(have foo1.0 qux1.0)
--> "have" is invalid; "have" argument "qux1.0" does not correspond to any "want" argument
```

The server is under no obligation of agreeing to any module or capability.
Clients should be prepared to gracefully handle unavailable modules or capabilities.
If the client finds that the server has not agreed to a module or capability that the client needs, it must exit.

## 5. Message types for `vt6/core1`

### 5.1. The `core1.sub` message

- Directionality: client to server
- Required capabilities: none
- Number of arguments: one or more

A client can send a `core1.sub` message to establish a **subscription** to a nonzero number of properties.
The arguments of the `core1.sub` message are the names of the properties which the client wishes to subscribe to.

*Rationale:* It is intentional that subscribing to a property is the only way for a client to retrieve a property's value.
This design nudges implementors towards handling server-initiated changes to properties properly.
Clients which only want to get the value of a property once are free to ignore any subsequent `core1.pub` messages.

A `core1.sub` message is invalid (within the meaning of section 2.4) if any of its arguments is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed, or
- the name of a property which is restricted to a capability to which the server has not agreed.

When a server receives a valid `core1.sub` message, it MUST subscribe the sending client to all properties in the message's argument list, and immediately notify the client with a corresponding `core1.pub` message (see below).

### 5.2. The `core1.pub` message

- Directionality: server to client
- Required capabilities: none
- Number of arguments: two or more (must be even)

A server can send a `core1.pub` message to inform a client of the values of certain properties.
It MUST have an even number of arguments.
The argument list consists of pairs of property names and property values.
That is, the second argument is the value of the property whose name is the first argument; the fourth argument (if present) is the value of the property whose name is the third argument; and so on.

A `core1.pub` message is invalid (within the meaning of section 2.4) if any of its odd-numbered arguments is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed,
- the name of a property which is restricted to a capability to which the server has not agreed, or
- the name of a property to which the recipient of the `core1.pub` message has not subscribed.

Moreover, a `core1.pub` message is invalid if any of its even-numbered arguments is a property value which is not valid for the property in question according to the specification defining the property.

A `core1.pub` message can be sent by the server at any time to notify the client of changes to the values of properties that the client has subscribed to.
Moreover, a `core1.pub` message MUST be sent by the server immediately upon receiving a valid `core1.sub` or `core1.set` message.
This message MUST contain the values of all properties named in the `core1.sub` or `core1.set` message, in the same order.
For `core1.sub` messages, this applies regardless of whether the client sending the message subscribes to properties for the first time, or whether subscriptions to these properties already existed for this client.

The following snippet shows examples of valid and invalid pairs of `core1.sub` messages and `core1.pub` replies.
The snippet is not a single message stream.
Each pair of messages is to be considered individually.
The snippet assumes that `foo1.bar` and `foo1.baz` are properties which are defined by the module `foo1` and which can assume arbitrary values, and that the server has agreed to using `foo1` and to all capabilities required by these properties.

```vt6
(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar hello-world foo1.baz 20)
--> valid; property "foo1.bar" has the value "hello-world" and "foo1.baz" has the value "20"

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar "hello-world" foo1.baz "20")
--> valid, and semantically identical to the previous example since the bareword hello-world represents the same string as the quoted string "hello-world"

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar (hello (world)) foo1.baz 20)
--> valid; property values may be arbitrarily complex s-expressions if the spec defining the property allows it

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar hello-world foo1.baz)
--> invalid; odd number of arguments

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar hello-world)
--> invalid; missing a property mentioned in the `core1.sub` message

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.bar hello-world foo1.baz 20 foo1.extra 10)
--> invalid; references a property not mentioned in the `core1.sub` message

(core1.sub foo1.bar foo1.baz)
(core1.pub foo1.baz 20 foo1.bar hello-world)
--> invalid; properties not listed in correct order
```

### 5.3. The `core1.set` message

- Directionality: client to server
- Required capabilities: none
- Number of arguments: two or more (must be even)

A client can send a `core1.set` message to change the value of one or more properties.
The argument list of a `core1.set` message has the same form as that of a `core1.pub` message (pairs of property names and values).

A `core1.set` message is invalid (within the meaning of section 2.4) if any of its odd-numbered arguments is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed, or
- the name of a property which is restricted to a capability to which the server has not agreed.

Notably, the message is not invalid if any of its even-numbered arguments is a value that is not permissible for the property in question.

*Rationale:* For non-trivial properties, the client might not have enough information to decide whether a given value is valid.

Setting a property implies subscribing to the property.
That is, a `core1.set` message sent from a client to a server implies a `core1.sub` message from the same client to the same server that mentions the same properties that are mentioned in the `core1.set` message.
This does not mean, however, that a separate `core1.pub` message must be sent to answer the implied `core1.sub` message.
For example:

```vt6
# this message...
(core1.set foo1.bar value1 foo1.baz value2)
# ...implies this message...
(core1.sub foo1.bar foo1.baz)
# ...and may result in a reply like this
(core1.pub foo1.bar value1 foo1.baz value3)
```

*Rationale:* For properties that only need to be set once, this reduces the number of messages required from four (sub-pub-set-pub) to two (set-pub).

A client's request to change the value of a property does not imply any obligation of the server to comply with this request.
The server may refuse to change the property's value at all (especially if the property is read-only), it may comply with the request, or set the property to an entirely different value, as long as the value is valid according to the property's specification.
This is why a `core1.pub` message is sent as a reply for a `core1.set` message.
The client SHOULD observe the `core1.pub` reply to learn whether the requested changes were accepted.

*Rationale:* For example, consider the case of the client trying to set `core1.client-msg-bytes-max` to `32768`.
The server might reject this, and report the previous value in the `core1.pub` response; or it might choose a value inbetween the previous and the requested value because it absolutely cannot process messages larger than that.

### 5.4. The `core1.nope` message

- Directionality: any
- Required capabilities: none
- Number of arguments: none

Upon receiving an invalid message, a server or client MAY reply by sending a `core1.nope` message. It MUST do so if:

1. the recipient cannot determine the message type of the invalid message, or
2. the recipient can determine, based on the message type of the invalid message, that the sender is waiting for a reply.

*Rationale:* The purpose of the `core1.nope` message is solely to unblock any processes which are waiting for a reply to their previous message.
This module does not define any generic error reporting mechanisms beyond this message type.
We consider it pointless to try to get any misbehaving process to start behaving correctly by pointing out their errors to them.

## 6. Properties for `vt6/core1`

### 6.1. The `core1.server-msg-bytes-max` property

- Acceptable values: unsigned integers
- Required capabilities: none
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the server to the client in bytes.
The value of this property MUST NOT be larger than 1024.

*Rationale:* The upper limit is important because clients are therefore assured that a 1 KiB buffer can hold any single message sent by the server, unless a different limit is negotiated.
We choose this standard buffer size of 1 KiB such that most, if not all, messages that ever need to be sent fit into this buffer, without wasting too much memory on buffers.

### 6.2. The `core1.client-msg-bytes-max` property

- Acceptable values: unsigned integers
- Required capabilities: none
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the client to the server in bytes.
The value of this property MUST NOT be smaller than 1024.

*Rationale:* The lower limit is important because clients are therefore assured that any messages smaller than 1 KiB will be accepted by any server, unless a different limit is negotiated.
The rationale from section 6.1 applies respectively.

The client MUST observe the server response when setting this property, because the server may reject the new property value or choose a compromise value.
