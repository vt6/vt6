<!-- draft -->
# `vt6/core1.0` - Fundamental protocols and interface contracts

The canonical URL for this document is <https://vt6.io/std/core/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

This document uses augmented Backus-Naur form (ABNF) as defined in [RFC 5234](https://tools.ietf.org/html/rfc5234).

TODO notes that need to be incorporated into the document:
- define how stdin, stdout, stderr are special (unsoliticed messages on stdin get passed to stdout and vice versa, unsolicited messages on stderr and other BSs get discarded)
- Routing and multiplexing is not a problem for most clients. When receiving unsolicited messages on stdin, they can just pass them through to stdout, and vice versa. Only programs that route text in complex ways (e.g. processes distributing input to several workers in parallel) need to maintain internal routing state. A regular qshell will just route everything to its foreground process unconditionally, thus not requiring extra internal state.
- maybe put in a rationale that we only have *either* events flowing in the text's direction (text, input events, output annotations) *or* request-response workflows (want-have, "get password", "choose from dropdown menu", etc.) - consider making it a SHALL that messages fall into one of these categories
- restrict `nope` to syntax errors, semantic errors must be indicated by a response message as defined by the module defining the request message (rationale: syntax errors can be detected by the next in line, but semantic errors can only be detected by the ultimate receiver; a generic `nope` for semantic errors would reintroduce the routing problem)
- note to self: platform-specific methods for stream forking have been dropped; do we need to add language to describe that processes launching other processes need to supply them with valid stdin/stdout/stderr that work as expected?

## 1. Definitions and platform requirements

In terminal applications, most textual data flows through one-directional pipes.
The terminal sends input text into the first program in the pipeline.
Standard output from one program in the pipeline is the next program's standard input.
And finally, the standard output at the end of the pipeline gets sent to the terminal for display.

On VT6-enabled terminals, those one-directional pipes are augmented with a two-directional structured message protocol that supersedes the [special capabilities of terminal devices defined, for example, by POSIX](https://linux.die.net/man/3/termios), as well as the traditional output markup using ANSI escape sequences.

### 1.1. Text streams

In the context of VT6, a **basic stream** is a bidirectional byte stream, an object with two ends such that byte strings written into one end are read on the other end in the same order.
Despite being bidirectional, unstructured text is only allowed to move through a basic stream in one direction (see section 2.3).
The programs at both ends of the basic stream are therefore called the **producer** and the **consumer** for that basic stream.
Both are collectively referred to as the basic stream's **peers**.
Only VT6 messages can flow through the basic stream in both directions, and only once the upgrade procedure described in section 2.3 has been performed.
A basic stream that has not been upgraded using this procedure therefore works like a traditional one-directional pipe.

A **VT6 application** is any program that can act as the producer or the consumer of a basic stream.

### 1.2. Message types and properties

A **message type** is a name for a kind of message (see section 2) that can be sent on a basic stream, either from producer to consumer or vice-versa.
Each message type is defined by its name and a set of criteria describing when a message of that type is to be considered valid by the recipient.
These criteria include at least:

- the directionality (whether the message may be sent from a producer to a consumer, or vice-versa, or both),
- the number of arguments that a message of this type may contain,
- the format and/or structure of said arguments,
- the behavior that is expected of the recipient upon having received the message.

A **property** is a quantifiable aspect which describes the publisher, or the basic stream over which messages concerning this property are exchanged.
Each property is **published** either by the producer or the consumer.
The peer that is not the publisher of the property is called its **observer**.
Each concrete value of a property is represented as a byte string, but for any given property, not all byte strings may be valid values.
The value of a property may influence how the publisher reacts to a message from the observer.
It may also influence how the observer reacts to a message from the publisher if (and only if) the observer has subscribed to this property (see section 5.1).

Each property is defined by its name and at least the following criteria:

- the directionality (whether the property is published by producers, or by consumers),
- the set of values that the property can have,
- whether, and under which circumstances, the observer may update the property's value (see section 5.3),
- how the behavior of both peers is influenced by the value of this property.

For each message type, there SHALL NOT be a property of the same name.

*Rationale:* Even though technically possible, it would cause unnecessary confusion.

### 1.3. Modules

```abnf
letter     = %x41-5A / %x61-7A                  ; letters A-Z and a-z
identifier = ( letter / "_" ) *( letter / "-" / "_" )
```

The VT6 protocol is divided into **modules**.
Each module has a name which is accepted by `<identifier>`.
For example, this document concerns the module `core`.
When it is not clear from the context that a given identifier refers to a module name, the prefix `vt6/` may be prepended to it.

A module is considered **official** if its specifications are developed in the same location as this specification.
The name of any unofficial module MUST start with a leading underscore and SHOULD indicate the organization that is responsible for its specification.

A module is considered **private** if it is intended to only be used between applications of a single vendor.
The name of any private module SHOULD start with two leading underscores.

*Rationale:* We strive to avoid name clashes between modules by different vendors, and reserve short module names for official modules to minimize message length for common messages.

Modules partition the VT6 protocol into parts which each may or may not be supported by a given VT6 application.
This includes, most prominently, message types and properties.

```abnf
scoped-identifier = identifier "." identifier
message-type      = "want" / "have" / "nope" / scoped-identifier
```

Modules act as namespaces for message types and properties.
Each message type or property name MUST be accepted by `<scoped-identifier>`, and the part before the dot MUST be equal to the name of the module defining it.
As an exception, the module "core" is allowed to define the message types "want", "have" and "nope" which do not contain a module name (see sections 4 and 5).

For example, the module `example` may define a message type named `example.foo` and a property named `example.bar`, but not a message type named `sample.foo` or a property named `sample.bar`.

### 1.4. Module versions

```abnf
digit   = %x30-39 ; decimal digits 0-9
nzdigit = %x31-39 ; non-zero decimal digits 1-9

version-number = "0" / ( nzdigit *digit )

major-version = version-number
minor-version = version-number
full-version  = major-version "." minor-version
```

Each module can have multiple **versions**.
Each module version has a **major version number** and a **minor version number**, as accepted by the `<major-version>` and `<minor-version>` grammar elements defined above.
When both version numbers are shown together, they are formatted as implied by the definition of the `<full-version>` grammar element defined above.

When referring to a module version in specifications and other documents, the recommended way is to append the full version number to the module name including the `vt6/` prefix.
For example, this document specifies version 1.0 of the module `core`, so the recommended identifier for this module version is `vt6/core1.0`.

Each module specification MUST clearly indicate the module name and full version number, preferably by including the recommended module version identifier in the document title, like this document does.

When the first specification of a module is created, its full version number MUST be set to `1.0`.
Everytime a new specification of that module is released, the module version MUST be adjusted as follows:

1. The minor version number is incremented.
2. Then, if the specification has been changed in a backwards-incompatible way compared to the previous release (see section 1.5), the major version number is incremented and the minor version number is reset to 0.

This requirement does not apply when the release is only a draft or pre-release that is not considered normative, and clearly labeled as such.

**Rationale:** This follows the basic notion of [semantic versioning](http://semver.org/spec/v2.0.0.html), albeit massively simplified to suit the usecase of module specifications.

Each module specification whose minor version number is bigger than 0 SHOULD indicate which parts of it have been added or changed compared to previous specifications of that module with the same major version number.

**Rationale:** Implementors should not have to `diff` specification documents manually.

### 1.5. Compatibility across module versions

The following changes to a module specification are considered **backwards-compatible**:

- addition of a new message type or property
- deprecation (but not removal) of an existing message type or property
- definition of previously undefined or underdefined behavior of an existing message type or property
- copyediting

Every other change to a module specification is considered **backwards-incompatible**, especially:

- removal of a message type or property
- change of behavior of an existing message type or property in such a way that there may exist VT6 applications that conform to the previous module version, but not to the current one

As an additional rule, all versions of the `core` module MUST be backwards-compatible with the parts of this specification that relate to all application behavior that takes place on a basic stream before a concrete version of the `core` module has been agreed to by the basic stream's peers (see section 3).
This includes, specifically:

- the parts of sections 1 and 2 that describe how consumer and producer upgrade a basic stream and use it to exchange messages, and
- the syntax of `want`, `have` and `nope` messages as described in sections 2 and 4.
  Those message types are therefore called **eternal**.

### 1.6. Platforms

A **platform** is an operating environment which is admissible for VT6 applications.
A platform SHALL define which operating-system-level objects can be used as basic streams.

Basic streams obtained through these methods SHALL be wholly separate from the existing basic stream for the purposes of the VT6 specifications.

*Rationale:* When a shell launches a command (or, in general, when any application launches a child process), the basic streams given to the command as standard input and output SHOULD always be new basic streams, not just duplicates.
This is because the VT6 protocol assumes that each basic stream is only used by exactly one producer and exactly one consumer.
If we just gave a copy of the existing basic streams used by the shell, messages directed to the shell could be received by its child process or vice versa.
Also, the child process would not know the state of the basic stream, for instance, which modules have been negotiated.

Each platform is defined by a **platform integration module**, which is a VT6 module.

For each official module that references **platform-specific behavior**, any module version of a platform integration module MUST define said behavior for its platform, or it MUST define that the module referencing platform-specific behavior is not supported on its platform.
This does not apply to platform-specific behavior that is first described in module versions released after the module version in question of the platform integration module.

A platform integration module MAY define message types and properties which are only available on the platform defined by it.

*The remainder of this section is non-normative.*

The following platform integration modules are available at the time of publication of this document:

- [vt6/posix](../../posix/) for operating systems that implement the POSIX specification

## 2. Messages

### 2.1. Syntax

#### 2.1.1. Byte strings

```abnf
byte   = %x00-FF ; any single byte
length = "0" | nzdigit *digit

byte-string = length ":" *byte ","
```

In the context of VT6 messages, a **byte string** is a sequence of bytes such that:

- it is accepted by `<byte-string>`, and
- the number of bytes between the first colon and the trailing comma is equal to the decimal value of the sequence of ASCII digits before the first colon.

The sequence of bytes between the first colon and the trailing comma is called the **value** of the byte string.

*Rationale:* This is the [netstring encoding](https://cr.yp.to/proto/netstrings.txt) first described by Daniel J. Bernstein.

#### 2.1.2. Messages

```abnf
message = "{" length "|" 1*byte-string "}"
```

A **VT6 message** (or just **message**, if the term is not ambiguous) is a nonempty sequence of byte strings, such that:

- it is accepted by `<list>`,
- the number of byte strings in the sequence after the first pipe symbol is equal to the decimal value of the sequence of ASCII digits before the first pipe symbol, and
- the value of the first byte string is accepted by `<message-type>`.

The first byte string in a message is therefore called the message's **type**.
Any following byte strings are called the message's **arguments**.
A message may have arbitrarily many arguments, including zero arguments.

*Rationale:* We avoid compactly-coded escape sequences like those specified by [ECMA-48](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-48,%202nd%20Edition,%20August%201979.pdf) aka ANSI&nbsp;X3.64 aka ISO/IEC&nbsp;6429 because of the risk that escape sequences specified by different modules collide with each other.
We choose an adaptation of the netstring format because it can be implemented very easily, both on the generating and on the parsing side.
We use different sigils for argument lists (the pipe symbol) and byte strings (the colon symbol), so that the syntax can later be expanded to allow for nested lists.
The curly brackets that enclose messages serve as a sequence point where parsing can be resumed after a parsing error (see section 2.2).

```abnf
fenced-message = escape-char message escape-char

escape-char = %x1B
```

A message is **fenced** when it is preceded by one ESC character and succeeded by another ESC character.

#### 2.1.3. Human-readable representation

The following alternative representation for byte strings and messages may be used when showing messages in specifications or informational displays, such as logs:

- Byte strings whose value matches the regular expression `^[A-Za-z0-9._-]*$` are represented directly by their value.
- Other byte strings are represented as C string literals with the same value.
- Messages are represented by a whitespace-separated concatenation of the representations of the byte strings contained in it, enclosed in parentheses.

*Rationale:* This format is much more human-readable and thus better suited for examples within specifications, or for diagnostic output of programs that process VT6 messages.

For example, a human-readable representation of the message `{3|8:core.set,13:example.title,13:hello "world",}` is `(core.set example.title "hello \"world\"")`.

### 2.2. Invalid messages, and handling thereof

A message is **invalid** if...

- it does not conform to the definitions above,

- the message's arguments do not conform to the requirements for the message's type, as stated in the specification defining the message type in question,

- the length of the message (including the outer curly braces) exceeds the maximum message size of 1024 bytes, or

- the message type is unknown or its use has not been agreed to on the basic stream over which it is received (see section 3).

Receipt of an invalid message MUST NOT cause any effect (besides error responses, see section 4.1) that can be observed by the sender.

### 2.3. Using basic streams

#### 2.3.1. Exchanging messages over basic streams

In order to exchange messages using a basic stream, the basic stream MUST first be upgraded using the following procedure:

1. Upon gaining access to the basic stream, the consumer SHALL immediately write the magic string `<ESC>[6V` (decimal byte sequence 27, 91, 54, 86) into it.
2. Upon gaining access to the basic stream, the producer SHALL immediately attempt to read from it.
   Once it reads the aforementioned magic string, it SHALL immediately reply by writing the same magic string back into the same basic stream.
   The producer SHALL then consider the basic stream upgraded for message exchange.
3. Once the consumer reads from the basic stream the magic string transmitted by the producer, the consumer SHALL consider the basic stream upgraded for message exchange.

While the basic stream is **not** considered upgraded:

- Both consumer and producer SHALL NOT attempt to exchange messages over the basic stream.
- Any bytes transmitted over the basic stream from consumer to producer SHALL be ignored by the producer.
- Any bytes transmitted over the basic stream from producer to consumer SHALL be interpreted as text data.

Once the basic stream has been upgraded to support message exchange:

- The consumer can send a message to the producer by writing it onto the basic stream directly.
- The producer can send a message to the consumer by writing it into the basic stream, surrounded by one ESC character on each side so that it is fenced.
- The producer can send text data to the consumer by writing it into the basic stream, with each ESC character that is part of the text data doubled, to avoid confusion with the ESC characters surrounding fenced messages.

When a producer reads bytes from an upgraded basic stream that are not part of a VT6 message (either because of syntax errors or because the message exceeds the producer's maximum message size), it SHALL discard all bytes until a `{` character is found, and attempt to parse a message from that point, repeating this process until a valid message is encountered.

When a consumer observes the initial `<ESC>{` of a fenced message on an upgraded basic stream, but then fails to read the rest of a complete fenced message (either because of syntax errors or because the message exceeds the consumer's maximum message size), it SHALL continue to read until the trailing `}<ESC>` of the fenced message is found, discard all bytes read including the `}<ESC>` characters, and continue reading from the basic stream.

### 2.4. Predefined property types

When a property is said to **accept string values**, this means that the set of acceptable values for this property is the set of all byte strings whose value is a properly UTF-8-encoded string.

*Rationale:* [utf8everywhere.org](http://utf8everywhere.org) nicely sums up the arguments for not bothering with other text encodings.

```abnf
integer          = "0" / ( [sign] nzdigit *digit )
unsigned-integer = "0" / ( nzdigit *digit )

sign = "+" / "-"
```

When a property is said to **accept integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<integer>` grammar element defined above.
Analogously, when a property is said to **accept unsigned integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<unsigned-integer>` grammar element defined above.

In both these cases, the **numerical value** of each such byte string is the decimal value of the sequence of digits in the byte string's value.
The module specification defining the property may impose additional restrictions on the numerical value of the property.

Section 6 of this specification uses the property types defined in this section.
Other module specifications which use some or all of the property types defined in this section SHALL reference this section.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document uses the predefined property types from section 2.4 of `vt6/core1.0`.

## 3. Protocol negotiation

Before the message types and properties of a module can be used on a basic stream, usage of the module must have been agreed to by both peers.
A peer **agrees to** using a module by answering a `want` message from its counterpart with a corresponding `have` message.

### 3.1. The `want` message

- Directionality: any
- Number of arguments: two or more

A peer can send a `want` message to its counterpart to request usage of a module.
The first argument MUST be the module name, and the remaining arguments SHALL be the maximal module versions that the sender supports.
Each module version MUST be formatted according to the `<full-version>` grammar element defined above.
Each module version with a minor version number greater than zero implies support for all module versions with the same module name, same major version, and a smaller minor version.
For example, the following `want` message indicates that the sender wants to use either major version 1 up to minor version 3 or major version 2 up to minor version 1 of the `example` module.

```vt6
(want example 1.3 2.1)
```

The set of module versions **offered by** a `want` message contains all module versions for which the message contains a module version with equal major version and greater or equal minor version.
For example, the message shown above offers versions `1.0`, `1.1`, `1.2`, `1.3`, `2.0`, and `2.1` of the `example` module.

### 3.2. The `have` message

- Directionality: any
- Number of arguments: zero or two

Upon receiving a valid `want` message, the recipient MUST reply with a `have` message to indicate if it agrees to using the requested module.
If the `want` message is valid, but the recipient does not agree to using any of the offered module versions, it MUST reply with a `have` message with zero arguments.

If the recipient agrees to using the requested module, it MUST reply with a `have` message with two arguments: the module name and the accepted module version.
The module version MUST be formatted according to the `<full-version>` grammar element defined above.
The module version MUST have been offered by the original `want` message.
Once this `have` message has been sent, both peers may use all message types, properties and behavior defined in the accepted module version.

The recipient MUST NOT agree to using a module if it does not support any of the offered module versions.
Applications MUST NOT agree to using a module version when a different version of the same module has already been agreed to on the same basic stream.
Applications MAY agree to using different versions of the same module on different basic streams.

When a `want` message concerns the same module as an earlier `want` message received by the same peer on the same basic stream, the recipient MUST reply consistently.
If the recipient did not agree to using the module in the earlier `have` message, it MUST NOT agree to using any module versions that were already offered by the earlier `want` message.
If the recipient agreed to using the module in the earlier `have` message, it MUST agree to using the same module version again if the agreed module version is offered by the current `want` message.

The following snippet shows examples of streams of `want` messages and `have` replies.
Each set of messages, as separated by an empty line, is to be considered as occurring on separate basic streams.

```vt6
(want core 1.0)
(have core 1.0)
(want foo 2.3)
(have foo 2.3)
--> peers can now use core1.0 module and foo2.3 module

(want core 1.2)
(have core 1.0)
(want foo 2.1)
(have foo 2.0)
--> peers can only use core1.0 module and foo2.0 module, not the requested higher versions

(want core 1.3 2.1)
(have core 2.1)
--> peers can now use core2.1 module, but not core1.x modules

(want core 1.0)
(have core 1.0)
(want foo 1.7 2.3)
(have)
--> peers can now use core1.0 module, but not foo module
```

VT6 applications are under no obligation of agreeing to any module.
Their peers should be prepared to gracefully handle unavailable modules.
If an application finds that its peer has not agreed to a module that it needs, it must exit.

## 4. Other eternal message types

### 4.1. The `nope` message

- Directionality: any
- Number of arguments: none

Upon receiving an invalid message, the recipient MAY reply by sending a `nope` message with no arguments.
It MUST do so if:

1. it cannot determine the message type of the invalid message, or
2. it can determine, based on the message type of the invalid message, that the sender is waiting for a reply.

As an exception, the recipient SHALL NOT send a `nope` message when a module that both peers have agreed to mandates a different behavior for the invalid message in question.

*Rationale:* The purpose of the `nope` message is solely to unblock any processes which are waiting for a reply to their previous message.
This module does not define any generic error reporting mechanisms beyond this message type.
We consider it pointless to try to get any misbehaving process to start behaving correctly by pointing out their errors to them.

## 5. Message types for `vt6/core1.0`

### 5.1. The `core.sub` message

- Directionality: observer to publisher
- Number of arguments: one

The observer of a property can send a `core.sub` message to its publisher to establish a **subscription** to the property.
The argument is the name of that property.

*Rationale:* It is intentional that subscribing to a property is the only way to retrieve a property's value.
This design nudges implementors towards handling publisher-initiated changes to properties properly.

A `core.sub` message is invalid (within the meaning of section 2.2) if its argument is not the name of a property, or if it is not defined by a module version whose usage has been agreed to.

Upon receiving a valid `core.sub` message, the recipient MUST record a subscription to the specified property, and immediately notify the sender with a corresponding `core.pub` message (see below).

### 5.2. The `core.pub` message

- Directionality: publisher to observer
- Number of arguments: two

The publisher of a property can send a `core.pub` message to inform the observer of the value of the property.
The first argument SHALL be the name of a property.
The second argument SHALL be the value of that property.

A `core.pub` message is invalid (within the meaning of section 2.2) if its first argument is not the name of a property, or the name of a property which is not defined by a module version whose usage has been agreed to.

Moreover, a `core.pub` message is invalid if its second argument is not a valid value for the property in question according to the specification defining the property.

Finally, a `core.pub` message is only valid if the observer is subscribed to the property in question, unless the `core.pub` message is a direct reply to a valid `core.set` message.

A `core.pub` message can be sent by the publisher at any time to notify the observer of changes to the values of a property that the observer has subscribed to.
Upon receiving a valid `core.sub` or `core.set` message, the publisher MUST reply immediately with a `core.pub` message for the same property.

### 5.3. The `core.set` message

- Directionality: observer to publisher
- Number of arguments: two

The observer of a property can send a `core.set` message to its publisher to change the value of a property.
The argument list of a `core.set` message has the same form as that of a `core.pub` message (a pair of property name and value).

A `core.set` message is invalid (within the meaning of section 2.2) if its argument is not the name of a property, or if it is not defined by a module version whose usage has been agreed to.

The message is *not* invalid if the second argument is a value that is not permissible for the property in question, and the message is otherwise valid.

*Rationale:* For non-trivial properties, the observer might not have enough information to decide whether a given value is valid.

An observer's request to change the value of a property does not imply any obligation of the publisher to comply with this request.
The publisher may refuse to change the property's value at all (especially if the property is read-only), it may comply with the request, or set the property to an entirely different value, as long as the value is valid according to the property's specification.
This is why a `core.pub` message is sent in reply to a `core.set` message.
The observer SHOULD observe the `core.pub` reply to learn whether the requested changes were accepted.
