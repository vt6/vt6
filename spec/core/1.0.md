<!-- draft -->
# `vt6/core1.0` - Fundamental protocols and interface contracts

The canonical URL for this document is <https://vt6.io/std/core/1.0/>.

**This is a non-normative draft.**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

This document uses augmented Backus-Naur form (ABNF) as defined in [RFC5234](https://tools.ietf.org/html/rfc5234).

## 1. Definitions and platform requirements

### 1.1. Servers and clients

VT6 is a protocol which is spoken between **VT6 servers** and **VT6 clients**.
A process that acts both as a VT6 client to at least one process and as a VT6 server to at least one process at the same time is called as **VT6 proxy**.

*Rationale:* In the most common setup (programs being started by a shell inside a terminal emulator), the terminal emulator acts as the server.
The shell and the programs started by it are the clients.

A **platform** is an operating environment which is admissible for VT6 clients and/or servers.

A platform for VT6 servers SHALL define how a server can launch other processes which can then act as VT6 clients, or it alternatively SHALL define a method for the server to delegate this task to other processes.

If the platform allows VT6 client processes to be started while a VT6 server is not present, the platform MUST define a method for client processes to determine whether a VT6 server is present.
If no VT6 server is present, the client process SHALL not be considered a VT6 client for the purpose of this specification, and any other specifications that inherit the meaning of the term "VT6 client" from it.

### 1.2. Server connections

A **bidirectional byte stream** is an object from which byte strings can be read and into which byte strings can be written.
A VT6 client SHALL have access to a bidirectional byte stream, which is called this client's **standard input/output**.

A platform MAY define a method by which clients can gain access to further bidirectional byte streams.
byte streams obtained through this method are called **server connections**.
When a client writes a byte string into a server connection, it MUST NOT be received by any process but this client's server.
When a client reads a byte string from a server connection, it SHALL have been sent by this client's server.
The server SHALL be able to distinguish between server connections opened by different clients, as well as different server connections opened by the same client.
This does not necessarily mean that the server can identify which server connection belongs to which client process.

*Rationale:* The server connection is separate from the standard input and output for scenarios where the VT6 client must be certain that the messages it sends are received by the VT6 server and not by another party (such as the next client in a shell pipe), and vice versa for server-to-client messages.
In POSIX, the server connection replaces the [special capabilities of terminal devices](https://linux.die.net/man/3/termios).

If a VT6 client has a method to obtain server connections, it is said to be operating in **normal mode**.
Otherwise, it is said to be operating in **multiplexed mode**.

*Rationale:* The multiplexed mode is intended for clients which only have a single bidirectional byte stream to their server and have no way of establishing a separate bidirectional byte stream to use as a server connection.
The most prominent example of this is a client connected via a remote login protocol such as [SSH](https://tools.ietf.org/html/rfc4251).

### 1.3. Message types and properties

A **message type** is a name for a kind of message (see section 2) that can be sent on a server connection, either from client to server or vice-versa.
Each message type is defined by its name and a set of criteria describing when a message of that type is to be considered valid by the recipient.
These criteria include at least:

- the directionality (whether the message may be sent from a client to a server, or vice-versa, or both),
- the number of arguments that a message of this type may contain,
- the format and/or structure of said arguments,
- the behavior that is expected of the recipient party upon having received the message.

A **property** is a quantifiable aspect which describes the server, or the server connection over which messages concerning this property are exchanged.
Each concrete value of a property is represented as a `<byte-string>` (as defined in section 2).
The value of a property may influence how the server reacts to a message from the client.
It may also influence how the client reacts to a message from the server if (and only if) the client has subscribed to this property (see section 5.1).

Each property is defined by its name and at least the following criteria:

- the set of values that the property can have,
- whether, and under which circumstances, the client may update the property's value (see section 5.3),
- how the behavior of client and server is influenced by the value of this property.

For each message type, there SHALL NOT be a property of the same name.

*Rationale:* Even though technically possible, it would cause unnecessary confusion.

### 1.4. Modules

```abnf
letter     = %x41-5A / %x61-7A                  ; letters A-Z and a-z
identifier = ( letter / "_" ) *( letter / "-" / "_" )
```

The VT6 protocol is divided into **modules**.
Each module has a name which is accepted by `<identifier>`.
For example, this document concerns the module `core`.
When it is not clear from the context that a given identifier refers to a module name, the prefix `vt6/` may be prepended to it.

A module is considered **official** if its specifications are developed in the same location as this specification.
The name of any unofficial module MUST start with a leading underscore and SHOULD indicate the organization that is responsible for its specification.

A module is considered **private** if it is intended to be used by client and server implementations of a single vendor.
The name of any private module SHOULD start with two leading underscores.

*Rationale:* We strive to avoid name clashes between modules by different vendors, and reserve short module names for official modules to minimize message length for common messages.

Modules partition the VT6 protocol into parts which each may or may not be supported by a given server or client.
This includes, most prominently, message types and properties.

```abnf
scoped-identifier = identifier "." identifier
message-type      = "want" / "have" / "nope" / scoped-identifier
```

Modules act as namespaces for message types and properties.
Each message type or property name MUST be accepted by `<scoped-identifier>`, and the part before the dot MUST be equal to the name of the module defining it.
As an exception, the module "core" is allowed to define the message types "want", "have" and "nope" which do not contain a module name (see sections 4 and 5).

For example, the module `example` may define a message type named `example.foo` and a property named `example.bar`, but not a message type named `sample.foo` or a property named `sample.bar`.

### 1.5. Module versions

```abnf
digit   = %x30-39 ; decimal digits 0-9
nzdigit = %x31-39 ; non-zero decimal digits 1-9

version-number = "0" / ( nzdigit *digit )

major-version = version-number
minor-version = version-number
full-version  = major-version "." minor-version
```

Each module can have multiple **versions**.
Each module version has a **major version number** and a **minor version number**, as accepted by the `<major-version>` and `<minor-version>` grammar elements defined above.
When both version numbers are shown together, they are formatted as implied by the definition of the `<full-version>` grammar element defined above.

When referring to a module version in specifications and other documents, the recommended way is to append the full version number to the module name including the `vt6/` prefix.
For example, this document specifies version 1.0 of the module `core`, so the recommended identifier for this module version is `vt6/core1.0`.

Each module specification MUST clearly indicate the module name and full version number, preferably by including the recommended module version identifier in the document title, like this document does.

When the first specification of a module is created, its full version number MUST be set to `1.0`.
Everytime a module specification is changed, the module version MUST be adjusted as follows:

1. The minor version number is incremented.
2. Then, if the specification has been changed in a backwards-incompatible way compared to the previous release (see section 1.5), the major version number is incremented and the minor version number is reset to 0.

This requirement does not apply when the release is only a draft or pre-release that is not considered normative, and clearly labeled as such.

**Rationale:** This follows the basic notion of [semantic versioning](http://semver.org/spec/v2.0.0.html), albeit massively simplified to suit the usecase of module specifications.

Each module specification whose minor version number is bigger than 0 SHOULD indicate which parts of it have been added or changed compared to previous specifications of that module with the same major version number.

**Rationale:** Implementors should not have to `diff` specification documents manually.

### 1.6. Compatibility across module versions

The following changes to a module specification are considered **backwards-compatible**:

- addition of a new message type or property
- deprecation (but not removal) of an existing message type or property
- definition of previously undefined or underdefined behavior of an existing message type or property
- copyediting

Every other change to a module specification is considered **backwards-incompatible**, especially:

- removal of a message type or property
- change of behavior of an existing message type or property in such a way that there may exist programs that conform to the previous module version, but not to the current one

As an additional rule, all versions of the `core` module MUST be backwards-compatible with the parts of this specification that relate to all client and server behavior that takes place before a concrete version of the `core` module has been agreed to by the server (see section 3).
This includes, specifically:

- the parts of sections 1 and 2 that describe how client and server establish a connection to each other and use it to exchange messages, and
- the syntax of `want`, `have` and `nope` messages as described in sections 2 and 4.
  Those message types are therefore called **eternal**.

### 1.7. Platform integration modules

Each platform is defined by a **platform integration module**, which is a VT6 module.

For each official module that references **platform-specific behavior**, any module version of a platform integration module MUST define said behavior for its platform, or it MUST define that the module referencing platform-specific behavior is not supported on its platform.
This does not apply for platform-specific behavior that is first described in module versions released after the module version in question of the platform integration module.

A platform integration module MAY define message types and properties which are only available on the platform defined by it.

*The remainder of this section is non-normative.*

The following platform integration modules are available at the time of publication of this document:

- [vt6/posix](../../posix/) for operating systems that implement the POSIX specification

## 2. Messages

### 2.1. Syntax

#### 2.1.1. Byte strings

```abnf
byte   = %x00-FF ; any single byte
length = "0" | nzdigit *digit

byte-string = length ":" *byte ","
```

In the context of VT6 messages, a **byte string** is a sequence of bytes such that:

- it is accepted by `<byte-string>`, and
- the number of bytes between the first colon and the trailing comma is equal to the decimal value of the sequence of ASCII digits before the first colon.

The sequence of bytes between the first colon and the trailing comma is called the **value** of the byte string.

*Rationale:* This is the [netstring encoding](https://cr.yp.to/proto/netstrings.txt) first described by Daniel J. Bernstein.

#### 2.1.2. Messages

```abnf
message = "{" length "|" 1*byte-string "}"
```

A **VT6 message** (or just **message**, if the term is not ambiguous) is a nonempty sequence of byte strings, such that:

- it is accepted by `<list>`,
- the number of byte strings in the sequence after the first pipe symbol is equal to the decimal value of the sequence of ASCII digits before the first pipe symbol, and
- the value of the first byte string is accepted by `<message-type>`.

The first byte string in a message is therefore called the message's **type**.
Any following byte strings are called the message's **arguments**.
A message may have arbitrarily many arguments, including zero arguments.

*Rationale:* We avoid compactly-coded escape sequences like those specified by [ECMA-48](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-48,%202nd%20Edition,%20August%201979.pdf) aka ANSI&nbsp;X3.64 aka ISO/IEC&nbsp;6429 because of the risk that escape sequences specified by different modules collide with each other.
We choose an adaptation of the netstring format because it can be implemented very easily, both on the generating and on the parsing side.
We use different sigils for argument lists (the pipe symbol) and byte strings (the colon symbol), so that the syntax can later be expanded to allow for nested lists.
The curly brackets that enclose messages serve as a sequence point where parsing can be resumed after a parsing error (see section 2.3).

#### 2.1.3. Human-readable representation

The following alternative representation for byte strings and messages may be used when showing messages in specifications or informational displays, such as logs:

- Byte strings whose value matches the regular expression `^[A-Za-z0-9._-]*$` are represented directly by their value.
- Other byte strings are represented as C string literals with the same value.
- Messages are represented by a whitespace-separated concatenation of the representations of the byte strings contained in it, enclosed in parentheses.

*Rationale:* This format is much more human-readable and thus better suited for examples within specifications, or for diagnostic output of programs that process VT6 messages.

For example, a human-readable representation of the message `{3|8:core.set,13:example.title,11:hello "world",}` is `(core.set example.title "hello \"world\"")`.

#### 2.1.4. Message streams

```abnf
message-stream = *( *space message ) *space
```

A **VT6 message stream** (or just **message stream**, if the term is not ambiguous) is a sequence of VT6 messages which are optionally preceded, succeeded and/or separated by whitespace.

*Rationale:* Allowing for whitespace between messages is especially useful when messages are emitted by a script in a language where a `print` operation appends a line separator by default.

```abnf
fenced-message-stream = escape-char message-stream escape-char

escape-char = %x1B
```

A message stream is **fenced** when it is preceded by one ESC character and succeeded by another ESC character.

### 2.2. Server-client communication

When a VT6 client is running in normal mode, it sends messages to its server by writing a message stream into a server connection, and receives messages from the server by reading a message stream from the same server connection.
Furthermore, it can read input data from standard input and write output data to standard output.
This specification does not restrict the form of these input and output data.

When a VT6 client is running in multiplexed mode, it sends messages to its server by writing a *fenced* message stream onto the standard output.
Any ESC character that is part of the output data or of a message inside the fenced message stream must be escaped by doubling it.

Conversely, a VT6 client running in multiplexed mode receives messages from its server by reading a *fenced* message stream from the standard input, whenever a single ESC character is encountered.
Any two consecutive ESC characters SHALL be interpreted as a single ESC character in the input data or in the current message.

A VT6 client running in multiplexed mode MUST write the magic string `<ESC>[6V` (decimal byte sequence 27, 91, 54, 126) into the standard output before writing anything else.
The magic string is not considered to be part of the output data nor does it start a fenced message stream, so the escaping rule for ESC characters stated above does not apply.

If the client fails to do so, all data written by the client into its standard output MUST be considered output data and the escaping rule for ESC characters does not apply.
Furthermore, fenced message streams MUST NOT be written into the client's standard input, and the escaping rule for ESC characters does not apply to the input data written into it, either.

### 2.3. Invalid messages, and handling thereof

A message is **invalid** if...

- it does not conform to the definitions above,

- the message's arguments do not conform to the requirements for the message's type, as stated in the specification defining the message type in question,

- the length of the message exceeds the recipient's maximum message size (see sections 6.1 and 6.2), usually 1024 bytes, or

- the message type is unknown or its use has not been agreed to by the server (see section 3).

Receipt of an invalid message MUST NOT cause any effect (besides error responses, see section 4.1) that can be observed by the sender.

If, while parsing a message stream, a recipient finds a message that cannot be parsed (either because of syntax errors or because the message exceeds the recipient's maximum message size), the recipient SHOULD employ the following algorithm to reset the stream parser and find the next well-formed message.

1. Discard all input characters until a `{` character is found.
2. Try to parse a message starting from this character.
3. If no valid message could be read, go back to step 1.

### 2.4. Predefined property types

When a property is said to **accept string values**, this means that the set of acceptable values for this property is the set of all byte strings whose value is a properly UTF-8-encoded string.

*Rationale:* [utf8everywhere.org](http://utf8everywhere.org) nicely sums up the arguments for not bothering with other text encodings.

```abnf
integer          = "0" / ( [sign] nzdigit *digit )
unsigned-integer = "0" / ( nzdigit *digit )

sign = "+" / "-"
```

When a property is said to **accept integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<integer>` grammar element defined above.
Analogously, when a property is said to **accept unsigned integer values**, this means that the set of acceptable values for this property is the set of all byte strings whose value matches the `<unsigned-integer>` grammar element defined above.

In both these cases, the **numerical value** of each such byte string is the decimal value of the sequence of digits in the byte string's value.
The module specification defining the property may impose additional restrictions on the numerical value of the property.

Section 6 of this specification uses the property types defined in this section.
Other module specifications which use some or all of the property types defined in this section SHALL reference this section.
The recommended way to do so is by including the following sentence near the start of the specification:

> This document uses the predefined property types from section 2.4 of `vt6/core1.0`.

## 3. Protocol negotiation

Before a client can use the message types and properties of a module, usage of the module must have been agreed to by the server.
A server **agrees to** using a module by answering a `want` message from the client with a corresponding `have` message.

### 3.1. The `want` message

- Directionality: client to server
- Number of arguments: two or more

A client can send a `want` message to the server to request usage of a module.
The first argument MUST be the module name, and the remaining arguments SHALL be the major versions of that module that the client supports.
Each major version MUST be formatted according to the `<major-version>` grammar element defined above.
For example, the following `want` message indicates that the client wants to use either major version 1 or major version 2 of the `example` module.

```vt6
(want example 1 2)
```

The first message that a client sends on each server connection MUST be a `want` message requesting the `core` module.

*Rationale:* All other modules depend on the definitions in `core`, so it must be negotiated first.

### 3.2. The `have` message

- Directionality: server to client
- Number of arguments: zero or two

Upon receiving a valid `want` message, the server MUST reply with a `have` message to indicate if it agrees to using the requested module.
If the `want` message is valid, but the server does not agree to the requested module, it MUST reply with a `have` message with zero arguments.

If the server agrees to using the requested module, it MUST reply with a `have` message with two arguments: the module name and the module version supported by the server.
Receipt of this `have` message entitles the client to use all message types, properties and behavior defined in that module version, or one with the same module name, same major version number and a smaller minor version number.
The module version MUST be formatted according to the `<full-version>` grammar element defined above.
The major version contained therein MUST be one of the major versions that appeared in the original `want` message.

The server MUST NOT agree to using a module if it does not support any of the major versions of that module which were offered in the `want` message.
The server MUST NOT agree to using multiple major versions of the same module across multiple `have` messages on the same server connection.
The server MAY agree to using different major versions of the same module on different server connections.

When a `want` message concerns the same module as an earlier `want` message, the server MUST reply consistently.
If it agreed to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST agree to this major version and offer the same full version as in the earlier `have` message.
If it did not agree to using a particular major version of a module in an earlier `have` message, and that major version is offered again in the current `have` message, it MUST NOT agree to this major version.

The following snippet shows examples of streams of `want` messages and `have` replies.
Each set of messages, as separated by an empty line, is to be considered as occurring on separate server connections.

```vt6
(want core 1)
(have core 1.0)
(want foo 2)
(have foo 2.3)
--> client can now use core1.0 module and either foo2.0, foo2.1, foo2.2 or foo2.3 module

(want core 1 2)
(have core 2.1)
--> client can now use either core2.0 or core2.1 module, but not core1.x modules

(want core 1)
(have core 1.0)
(want foo 1 2)
(have)
--> server did not agree to using foo module
```

The server is under no obligation of agreeing to any module.
Clients should be prepared to gracefully handle unavailable modules.
If the client finds that the server has not agreed to a module that the client needs, it must exit.

## 4. Other eternal message types

### 4.1. The `nope` message

- Directionality: any
- Number of arguments: none

Upon receiving an invalid message, a server or client MAY reply by sending a `nope` message with no arguments.
It MUST do so if:

1. it cannot determine the message type of the invalid message, or
2. it can determine, based on the message type of the invalid message, that the sender is waiting for a reply.

As an exception, the recipient SHALL NOT send a `nope` message when a module that the server has agreed to mandates a different behavior for the invalid message in question.

*Rationale:* The purpose of the `nope` message is solely to unblock any processes which are waiting for a reply to their previous message.
This module does not define any generic error reporting mechanisms beyond this message type.
We consider it pointless to try to get any misbehaving process to start behaving correctly by pointing out their errors to them.

## 5. Message types for `vt6/core1.0`

### 5.1. The `core.sub` message

- Directionality: client to server
- Number of arguments: one

A client can send a `core.sub` message to establish a **subscription** to a property.
The argument is the name of that property.

*Rationale:* It is intentional that subscribing to a property is the only way for a client to retrieve a property's value.
This design nudges implementors towards handling server-initiated changes to properties properly.

A `core.sub` message is invalid (within the meaning of section 2.3) if its argument is not the name of a property, or if it is defined by a module or module version to whose usage the server has not agreed.

When a server receives a valid `core.sub` message, it MUST subscribe the sending client to the specified property, and immediately notify the client with a corresponding `core.pub` message (see below).

### 5.2. The `core.pub` message

- Directionality: server to client
- Number of arguments: two

A server can send a `core.pub` message to inform a client of the value of a property.
The first argument SHALL be the name of a property.
The second argument SHALL be the value of that property.

A `core.pub` message is invalid (within the meaning of section 2.3) if its first argument is:

- not the name of a property,
- the name of a property in a module to whose usage the server has not agreed, or
- the name of a property to which the recipient of the `core.pub` message has not subscribed.

Moreover, a `core.pub` message is invalid if its second argument is not a valid value for the property in question according to the specification defining the property.

A `core.pub` message can be sent by the server at any time to notify the client of changes to the values of a property that the client has subscribed to.
Upon receiving a valid `core.sub` or `core.set` message, the server MUST reply immediately with a `core.pub` message for the same property.

### 5.3. The `core.set` message

- Directionality: client to server
- Number of arguments: two

A client can send a `core.set` message to change the value of a property.
The argument list of a `core.set` message has the same form as that of a `core.pub` message (a pair of property name and value).

A `core.set` message is invalid (within the meaning of section 2.3) if its argument is not the name of a property, or if it is defined by a module to whose usage the server has not agreed.

The message is *not* invalid if the second argument is a value that is not permissible for the property in question, and the message is otherwise valid.

*Rationale:* For non-trivial properties, the client might not have enough information to decide whether a given value is valid.

A client's request to change the value of a property does not imply any obligation of the server to comply with this request.
The server may refuse to change the property's value at all (especially if the property is read-only), it may comply with the request, or set the property to an entirely different value, as long as the value is valid according to the property's specification.
This is why a `core.pub` message is sent as a reply for a `core.set` message.
The client SHOULD observe the `core.pub` reply to learn whether the requested changes were accepted.

*Rationale:* For example, consider the case of the client trying to set `core.client-msg-bytes-max` to a larger value.
The server might reject this, and report the previous value in the `core.pub` response; or it might choose a value inbetween the previous and the requested value because it absolutely cannot process messages larger than that.

## 6. Properties for `vt6/core1.0`

### 6.1. The `core.server-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the server to the client in bytes.
The default value of this property MUST NOT be larger than 1024.

*Rationale:* The upper limit is important because clients are therefore assured that a 1 KiB buffer can hold any single message sent by the server, unless a different limit is negotiated.
We choose this standard buffer size of 1 KiB such that most, if not all, messages that ever need to be sent fit into this buffer, without wasting too much memory on buffers.

### 6.2. The `core.client-msg-bytes-max` property

- Acceptable values: unsigned integers
- Can be set by client: yes

The value of this property is the maximum length of a message sent from the client to the server in bytes.
The default value of this property MUST NOT be smaller than 1024.

*Rationale:* The lower limit is important because clients are therefore assured that any messages smaller than 1 KiB will be accepted by any server, unless a different limit is negotiated.
The rationale from section 6.1 applies respectively.

The client MUST observe the server response when setting this property, because the server may reject the new property value or choose a compromise value.
